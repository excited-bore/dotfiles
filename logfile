
chdir(/home/burp/Applications/.bash_aliases)
chdir(vim)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(vim)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(vim)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(vim)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(vim)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(vim)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(vim)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(vim)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(vim)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(vim)
chdir(/home/burp/Applications/.bash_aliases)
Executing:     aunmenu *
Executing:     vnoremenu PopUp.Cut                     "+x
Executing:     vnoremenu PopUp.Copy                    "+y
Executing:     anoremenu PopUp.Paste                   "+gP
Executing:     vnoremenu PopUp.Paste                   "+P
Executing:     vnoremenu PopUp.Delete                  "_x
Executing:     nnoremenu PopUp.Select\ All             ggVG
Executing:     vnoremenu PopUp.Select\ All             gg0oG$
Executing:     inoremenu PopUp.Select\ All             <C-Home><C-O>VG
Executing:     anoremenu PopUp.-1-                     <Nop>
Executing:     anoremenu PopUp.How-to\ disable\ mouse  <Cmd>help disable-mouse<CR>
Executing:   
Searching for "ftplugin.vim" in runtime path
Searching for "/home/burp/.config/nvim/ftplugin.vim"
Searching for "/etc/xdg/nvim/ftplugin.vim"
Searching for "/usr/share/nvim/runtime/ftplugin.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime)
chdir(/home/burp/Applications/.bash_aliases)
sourcing "/usr/share/nvim/runtime/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2006 Apr 30
line 5: 
line 6: if exists("did_load_ftplugin")
line 7:   finish
line 8: endif
line 9: let did_load_ftplugin = 1
line 10: 
line 11: augroup filetypeplugin
line 12:   au FileType * call s:LoadFTPlugin()
line 13: 
line 14:   func! s:LoadFTPlugin()
line 37: augroup END
finished sourcing /usr/share/nvim/runtime/ftplugin.vim
Searching for "/usr/lib/nvim/ftplugin.vim"
Searching for "indent.vim" in runtime path
Searching for "/home/burp/.config/nvim/indent.vim"
Searching for "/etc/xdg/nvim/indent.vim"
Searching for "/usr/share/nvim/runtime/indent.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime)
chdir(/home/burp/Applications/.bash_aliases)
sourcing "/usr/share/nvim/runtime/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2008 Feb 22
line 5: 
line 6: if exists("did_indent_on")
line 7:   finish
line 8: endif
line 9: let did_indent_on = 1
line 10: 
line 11: augroup filetypeindent
line 12:   au FileType * call s:LoadIndent()
line 13:   func! s:LoadIndent()
line 32: augroup END
finished sourcing /usr/share/nvim/runtime/indent.vim
Searching for "/usr/lib/nvim/indent.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/etc/xdg/nvim)
chdir(/home/burp/Applications/.bash_aliases)
sourcing "/etc/xdg/nvim/sysinit.vim"
line 1: " This line makes pacman-installed global Arch Linux vim packages work.
line 2: source /usr/share/nvim/archlinux.vim
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim)
chdir(/home/burp/Applications/.bash_aliases)
line 2: sourcing "/usr/share/nvim/archlinux.vim"
line 1: set runtimepath+=/usr/share/vim/vimfiles
finished sourcing /usr/share/nvim/archlinux.vim
continuing in /etc/xdg/nvim/sysinit.vim
finished sourcing /etc/xdg/nvim/sysinit.vim
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/.config/nvim)
chdir(/home/burp/Applications/.bash_aliases)
sourcing "/home/burp/.config/nvim/init.vim"
line 1: 
line 2: " These options and commands enable some very useful features in Vim, that
line 3: " no user should have to live without.
line 4: 
line 5: " Set 'nocompatible' to ward off unexpected things that your distro might
line 6: " have made, as well as sanely reset options when re-sourcing .vimrc
line 7: set nocompatible
line 8: 
line 9: " Attempt to determine the type of a file based on its name and possibly its
line 10: " contents. Use this to allow intelligent auto-indenting for each filetype,
line 11: " and for plugins that are filetype specific.
line 12: filetype off
Searching for "ftoff.vim" in runtime path
Searching for "/home/burp/.config/nvim/ftoff.vim"
Searching for "/etc/xdg/nvim/ftoff.vim"
Searching for "/usr/share/nvim/runtime/ftoff.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime)
chdir(/home/burp/Applications/.bash_aliases)
line 12: sourcing "/usr/share/nvim/runtime/ftoff.vim"
line 1: " Vim support file to switch off detection of file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2001 Jun 11
line 5: 
line 6: if exists("did_load_filetypes")
line 7:   unlet did_load_filetypes
line 8: endif
line 9: 
line 10: " Remove all autocommands in the filetypedetect group
line 11: silent! au! filetypedetect *
Error detected while processing /home/burp/.config/nvim/init.vim[12]../usr/share/nvim/runtime/ftoff.vim:
line   11:
E216: No such group or event: filetypedetect *
finished sourcing /usr/share/nvim/runtime/ftoff.vim
continuing in /home/burp/.config/nvim/init.vim
Searching for "/usr/lib/nvim/ftoff.vim"
Searching for "/usr/share/vim/vimfiles/ftoff.vim"
line 13: 
line 14: " Enable syntax highlighting
line 15: syntax on
line 15: so $VIMRUNTIME/syntax/syntax.vim
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/syntax)
chdir(/home/burp/Applications/.bash_aliases)
line 15: sourcing "/usr/share/nvim/runtime/syntax/syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2022 Apr 12
line 4: 
line 5: " This file is used for ":syntax on".
line 6: " It installs the autocommands and starts highlighting for all buffers.
line 7: 
line 8: if !has("syntax")
line 9:   finish
line 10: endif
line 11: 
line 12: " If Syntax highlighting appears to be on already, turn it off first, so that
line 13: " any leftovers are cleared.
line 14: if exists("syntax_on") || exists("syntax_manual")
line 15:   so <sfile>:p:h/nosyntax.vim
line 16: endif
line 17: 
line 18: " Load the Syntax autocommands and set the default methods for highlighting.
line 19: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in runtime path
Searching for "/home/burp/.config/nvim/syntax/synload.vim"
Searching for "/etc/xdg/nvim/syntax/synload.vim"
Searching for "/usr/share/nvim/runtime/syntax/synload.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/syntax)
chdir(/home/burp/Applications/.bash_aliases)
line 19: sourcing "/usr/share/nvim/runtime/syntax/synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2022 Apr 12
line 4: 
line 5: " This file sets up for syntax highlighting.
line 6: " It is loaded from "syntax.vim" and "manual.vim".
line 7: " 1. Set the default highlight groups.
line 8: " 2. Install Syntax autocommands for all the available syntax files.
line 9: 
line 10: if !has("syntax")
line 11:   finish
line 12: endif
line 13: 
line 14: " let others know that syntax has been switched on
line 15: let syntax_on = 1
line 16: 
line 17: " Line continuation is used here, remove 'C' from 'cpoptions'
line 18: let s:cpo_save = &cpo
line 19: set cpo&vim
line 20: 
line 21: " First remove all old syntax autocommands.
line 22: au! Syntax
line 23: 
line 24: au Syntax *^I^Icall s:SynSet()
line 25: 
line 26: fun! s:SynSet()
line 57: 
line 58: 
line 59: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
line 60: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 65: 
line 66: 
line 67: " Source the user-specified syntax highlighting file
line 68: if exists("mysyntaxfile")
line 69:   let s:fname = expand(mysyntaxfile)
line 70:   if filereadable(s:fname)
line 71:     execute "source " . fnameescape(s:fname)
line 72:   endif
line 73: endif
line 74: 
line 75: " Restore 'cpoptions'
line 76: let &cpo = s:cpo_save
line 77: unlet s:cpo_save
finished sourcing /usr/share/nvim/runtime/syntax/synload.vim
continuing in /usr/share/nvim/runtime/syntax/syntax.vim
line 20: 
line 21: " Load the FileType autocommands if not done yet.
line 22: if exists("did_load_filetypes")
line 23:   let s:did_ft = 1
line 24: else
line 25:   filetype on
Searching for "filetype.lua filetype.vim" in runtime path
Searching for "/home/burp/.config/nvim/filetype.lua"
Searching for "/home/burp/.config/nvim/filetype.vim"
Searching for "/etc/xdg/nvim/filetype.lua"
Searching for "/etc/xdg/nvim/filetype.vim"
Searching for "/usr/share/nvim/runtime/filetype.lua"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime)
chdir(/home/burp/Applications/.bash_aliases)
line 25: sourcing "/usr/share/nvim/runtime/filetype.lua"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime)
chdir(/home/burp/Applications/.bash_aliases)
Executing:   augroup filetypedetect
Executing:   runtime! ftdetect/*.vim
Searching for "ftdetect/*.vim" in runtime path
Searching for "/home/burp/.config/nvim/ftdetect/*.vim"
Searching for "/etc/xdg/nvim/ftdetect/*.vim"
Searching for "/usr/share/nvim/runtime/ftdetect/*.vim"
Searching for "/usr/lib/nvim/ftdetect/*.vim"
Searching for "/usr/share/vim/vimfiles/ftdetect/*.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/vim/vimfiles/ftdetect)
chdir(/home/burp/Applications/.bash_aliases)
line 0: sourcing "/usr/share/vim/vimfiles/ftdetect/PKGBUILD.vim"
line 1: au BufNewFile,BufRead PKGBUILD set filetype=PKGBUILD
finished sourcing /usr/share/vim/vimfiles/ftdetect/PKGBUILD.vim
continuing in nvim_exec() called at /usr/share/nvim/runtime/filetype.lua:0
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/vim/vimfiles/ftdetect)
chdir(/home/burp/Applications/.bash_aliases)
line 0: sourcing "/usr/share/vim/vimfiles/ftdetect/SRCINFO.vim"
line 1: au BufNewFile,BufRead .SRCINFO set filetype=SRCINFO
finished sourcing /usr/share/vim/vimfiles/ftdetect/SRCINFO.vim
continuing in nvim_exec() called at /usr/share/nvim/runtime/filetype.lua:0
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/vim/vimfiles/ftdetect)
chdir(/home/burp/Applications/.bash_aliases)
line 0: sourcing "/usr/share/vim/vimfiles/ftdetect/meson.vim"
line 1: au BufNewFile,BufRead meson.build set filetype=meson
line 2: au BufNewFile,BufRead meson_options.txt set filetype=meson
line 3: au BufNewFile,BufRead *.wrap set filetype=dosini
finished sourcing /usr/share/vim/vimfiles/ftdetect/meson.vim
continuing in nvim_exec() called at /usr/share/nvim/runtime/filetype.lua:0
Executing:   runtime! ftdetect/*.lua
Searching for "ftdetect/*.lua" in runtime path
Searching for "/home/burp/.config/nvim/ftdetect/*.lua"
Searching for "/etc/xdg/nvim/ftdetect/*.lua"
Searching for "/usr/share/nvim/runtime/ftdetect/*.lua"
Searching for "/usr/lib/nvim/ftdetect/*.lua"
Searching for "/usr/share/vim/vimfiles/ftdetect/*.lua"
not found in runtime path: "ftdetect/*.lua"
Executing:   augroup END
Executing:   
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime)
chdir(/home/burp/Applications/.bash_aliases)
finished sourcing /usr/share/nvim/runtime/filetype.lua
continuing in /usr/share/nvim/runtime/syntax/syntax.vim
Searching for "/usr/share/nvim/runtime/filetype.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime)
chdir(/home/burp/Applications/.bash_aliases)
line 25: sourcing "/usr/share/nvim/runtime/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2022 Sep 27
line 5: 
line 6: " Only run this if enabled
line 7: if !exists("do_legacy_filetype")
line 8:   finish
finished sourcing /usr/share/nvim/runtime/filetype.vim
continuing in /usr/share/nvim/runtime/syntax/syntax.vim
Searching for "/usr/lib/nvim/filetype.lua"
Searching for "/usr/lib/nvim/filetype.vim"
Searching for "/usr/share/vim/vimfiles/filetype.lua"
Searching for "/usr/share/vim/vimfiles/filetype.vim"
line 26:   let s:did_ft = 0
line 27: endif
line 28: 
line 29: " Set up the connection between FileType and Syntax autocommands.
line 30: " This makes the syntax automatically set when the file type is detected
line 31: " unless treesitter highlighting is enabled.
line 32: " Avoid an error when 'verbose' is set and <amatch> expansion fails.
line 33: augroup syntaxset
line 34:   au! FileType *^Iif !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
line 35: augroup END
line 36: 
line 37: " Execute the syntax autocommands for the each buffer.
line 38: " If the filetype wasn't detected yet, do that now.
line 39: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 40: " already was set manually (e.g., help buffers).
line 41: doautoall syntaxset FileType
Executing FileType Autocommands for "*"
autocommand if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif

Executing: if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  endif
line 42: if !s:did_ft
line 43:   doautoall filetypedetect BufRead
Executing BufReadPost Autocommands for "*"
autocommand <Lua 5: /usr/share/nvim/runtime/filetype.lua:11>

Executing: 
Executing BufReadPost Autocommands for "*"
autocommand if !did_filetype() && expand('<amatch>') !~ g:ft_ignore_pat | runtime! scripts.vim | endif

Executing: if !did_filetype() && expand('<amatch>') !~ g:ft_ignore_pat | runtime! scripts.vim | endif
Executing:  runtime! scripts.vim | endif
Searching for "scripts.vim" in runtime path
Searching for "/home/burp/.config/nvim/scripts.vim"
Searching for "/etc/xdg/nvim/scripts.vim"
Searching for "/usr/share/nvim/runtime/scripts.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime)
chdir(/home/burp/Applications/.bash_aliases)
line 0: sourcing "/usr/share/nvim/runtime/scripts.vim"
line 1: " Vim support file to detect file types in scripts
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2021 Jan 22
line 5: 
line 6: " This file is called by an autocommand for every file that has just been
line 7: " loaded into a buffer.  It checks if the type of file can be recognized by
line 8: " the file contents.  The autocommand is in $VIMRUNTIME/filetype.vim.
line 9: "
line 10: " Note that the pattern matches are done with =~# to avoid the value of the
line 11: " 'ignorecase' option making a difference.  Where case is to be ignored use
line 12: " =~? instead.  Do not use =~ anywhere.
line 13: 
line 14: " Only run when using legacy filetype
line 15: if !exists('g:do_legacy_filetype')
line 16:   finish
finished sourcing /usr/share/nvim/runtime/scripts.vim
continuing in BufReadPost Autocommands for "*"
Searching for "/usr/lib/nvim/scripts.vim"
Searching for "/usr/share/vim/vimfiles/scripts.vim"
Executing:  endif
line 44: endif
finished sourcing /usr/share/nvim/runtime/syntax/syntax.vim
continuing in /home/burp/.config/nvim/init.vim
line 16: 
line 17: " Relative number lines
line 18: set relativenumber 
line 19: 
line 20: " set the runtime path to include Vundle and initialize
line 21: set rtp+=~/.vim/bundle/Vundle.vim
line 22: call vundle#begin()
Searching for "autoload/vundle.vim" in runtime path
Searching for "/home/burp/.config/nvim/autoload/vundle.vim"
Searching for "/etc/xdg/nvim/autoload/vundle.vim"
Searching for "/usr/share/nvim/runtime/autoload/vundle.vim"
Searching for "/usr/lib/nvim/autoload/vundle.vim"
Searching for "/usr/share/vim/vimfiles/autoload/vundle.vim"
Searching for "/home/burp/.vim/bundle/Vundle.vim/autoload/vundle.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/.vim/bundle/Vundle.vim/autoload)
chdir(/home/burp/Applications/.bash_aliases)
line 22: sourcing "/home/burp/.vim/bundle/Vundle.vim/autoload/vundle.vim"
line 1: " Vundle        is a shortcut for Vim Bundle and Is a simple plugin manager for Vim
line 2: " Author:       gmarik
line 3: " HomePage:     http://github.com/VundleVim/Vundle.vim
line 4: " Readme:       http://github.com/VundleVim/Vundle.vim/blob/master/README.md
line 5: " Version:      0.10.2
line 6: 
line 7: " Plugin Commands
line 8: com! -nargs=+  -bar   Plugin call vundle#config#bundle(<args>)
line 10: 
line 11: com! -nargs=* -bang -complete=custom,vundle#scripts#complete PluginInstall call vundle#installer#new('!' == '<bang>', <f-args>)
line 13: 
line 14: com! -nargs=? -bang -complete=custom,vundle#scripts#complete PluginSearch call vundle#scripts#all('!' == '<bang>', <q-args>)
line 16: 
line 17: com! -nargs=0 -bang PluginList call vundle#installer#list('!' == '<bang>')
line 19: 
line 20: com! -nargs=? -bang   PluginClean call vundle#installer#clean('!' == '<bang>')
line 22: 
line 23: com! -nargs=0         PluginDocs call vundle#installer#helptags(g:vundle#bundles)
line 25: 
line 26: " Aliases
line 27: com! -nargs=* -complete=custom,vundle#scripts#complete PluginUpdate PluginInstall! <args>
line 28: 
line 29: " Vundle Aliases
line 30: com! -nargs=? -bang -complete=custom,vundle#scripts#complete VundleInstall PluginInstall<bang> <args>
line 31: com! -nargs=? -bang -complete=custom,vundle#scripts#complete VundleSearch  PluginSearch<bang> <args>
line 32: com! -nargs=? -bang                                          VundleClean   PluginClean<bang>
line 33: com! -nargs=0                                                VundleDocs    PluginDocs
line 34: com!                                                         VundleUpdate  PluginInstall!
line 35: com! -nargs=*       -complete=custom,vundle#scripts#complete VundleUpdate  PluginInstall! <args>
line 36: 
line 37: " Deprecated Commands
line 38: com! -nargs=+                                                Bundle        call vundle#config#bundle(<args>)
line 39: com! -nargs=? -bang -complete=custom,vundle#scripts#complete BundleInstall PluginInstall<bang> <args>
line 40: com! -nargs=? -bang -complete=custom,vundle#scripts#complete BundleSearch  PluginSearch<bang> <args>
line 41: com! -nargs=0 -bang                                          BundleList    PluginList<bang>
line 42: com! -nargs=? -bang                                          BundleClean   PluginClean<bang>
line 43: com! -nargs=0                                                BundleDocs    PluginDocs
line 44: com!                                                         BundleUpdate  PluginInstall!
line 45: 
line 46: " Set up the signs used in the installer window. (See :help signs)
line 47: if (has('signs'))
line 48:   sign define Vu_error    text=!  texthl=Error
line 49:   sign define Vu_active   text=>  texthl=Comment
line 50:   sign define Vu_todate   text=.  texthl=Comment
line 51:   sign define Vu_new      text=+  texthl=Comment
line 52:   sign define Vu_updated  text=*  texthl=Comment
line 53:   sign define Vu_deleted  text=-  texthl=Comment
line 54:   sign define Vu_helptags text=*  texthl=Comment
line 55:   sign define Vu_pinned   text==  texthl=Comment
line 56: endif
line 57: 
line 58: " Set up Vundle.  This function has to be called from the users vimrc file.
line 59: " This will force Vim to source this file as a side effect which wil define
line 60: " the :Plugin command.  After calling this function the user can use the
line 61: " :Plugin command in the vimrc.  It is not possible to do this automatically
line 62: " because when loading the vimrc file no plugins where loaded yet.
line 63: func! vundle#rc(...) abort
line 69: 
line 70: " Alternative to vundle#rc, offers speed up by modifying rtp only when end()
line 71: " called later.
line 72: func! vundle#begin(...) abort
line 76: 
line 77: " Finishes putting plugins on the rtp.
line 78: func! vundle#end(...) abort
line 82: 
line 83: " Initialize some global variables used by Vundle.
line 84: let vundle#bundle_dir = expand('$HOME/.vim/bundle', 1)
line 85: let vundle#bundles = []
line 86: let vundle#lazy_load = 0
line 87: let vundle#log = []
line 88: let vundle#updated_bundles = []
line 89: 
line 90: " vim: set expandtab sts=2 ts=2 sw=2 tw=78 norl:
finished sourcing /home/burp/.vim/bundle/Vundle.vim/autoload/vundle.vim
continuing in /home/burp/.config/nvim/init.vim
calling vundle#begin()

line 1:   let g:vundle#lazy_load = 1
line 2:   call call('vundle#rc', a:000)
calling vundle#rc()

line 1:   if a:0 > 0
line 2:     let g:vundle#bundle_dir = expand(a:1, 1)
line 3:   endif
line 4:   call vundle#config#init()
Searching for "autoload/vundle/config.vim" in runtime path
Searching for "/home/burp/.config/nvim/autoload/vundle/config.vim"
Searching for "/etc/xdg/nvim/autoload/vundle/config.vim"
Searching for "/usr/share/nvim/runtime/autoload/vundle/config.vim"
Searching for "/usr/lib/nvim/autoload/vundle/config.vim"
Searching for "/usr/share/vim/vimfiles/autoload/vundle/config.vim"
Searching for "/home/burp/.vim/bundle/Vundle.vim/autoload/vundle/config.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/.vim/bundle/Vundle.vim/autoload/vundle)
chdir(/home/burp/Applications/.bash_aliases)
line 4: sourcing "/home/burp/.vim/bundle/Vundle.vim/autoload/vundle/config.vim"
line 1: " ---------------------------------------------------------------------------
line 2: " Add a plugin to the runtimepath.
line 3: "
line 4: " arg    -- a string specifying the plugin
line 5: " ...    -- a dictionary of options for the plugin
line 6: " return -- the return value from vundle#config#init_bundle()
line 7: " ---------------------------------------------------------------------------
line 8: func! vundle#config#bundle(arg, ...)
line 23: 
line 24: 
line 25: " ---------------------------------------------------------------------------
line 26: "  When lazy bundle load is used (begin/end functions), add all configured
line 27: "  bundles to runtimepath and reorder appropriately.
line 28: " ---------------------------------------------------------------------------
line 29: func! vundle#config#activate_bundles()
line 33: 
line 34: 
line 35: " ---------------------------------------------------------------------------
line 36: " Initialize Vundle.
line 37: "
line 38: " Start a new bundles list and make sure the runtimepath does not contain
line 39: " directories from a previous call. In theory, this should only be called
line 40: " once.
line 41: " ---------------------------------------------------------------------------
line 42: func! vundle#config#init()
line 48: 
line 49: 
line 50: " ---------------------------------------------------------------------------
line 51: " Add a list of bundles to the runtimepath and source them.
line 52: "
line 53: " bundles -- a list of bundle objects
line 54: " ---------------------------------------------------------------------------
line 55: func! vundle#config#require(bundles) abort
line 66: 
line 67: 
line 68: " ---------------------------------------------------------------------------
line 69: " Create a bundle object from a bundle specification.
line 70: "
line 71: " name   -- the bundle specification as a string
line 72: " opts   -- the options dictionary from then bundle definition
line 73: " return -- an initialized bundle object
line 74: " ---------------------------------------------------------------------------
line 75: func! vundle#config#init_bundle(name, opts)
line 84: 
line 85: 
line 86: " ---------------------------------------------------------------------------
line 87: " Check if the current bundle name has already been used in this running
line 88: " instance and show an error to that effect.
line 89: "
line 90: " bundle -- a bundle object whose name is to be checked
line 91: " return -- 0 if the bundle's name has been seen before, 1 otherwise
line 92: " ---------------------------------------------------------------------------
line 93: funct! s:check_bundle_name(bundle)
line 107: 
line 108: 
line 109: " ---------------------------------------------------------------------------
line 110: " Parse the options which can be supplied with the bundle specification.
line 111: " Corresponding documentation: vundle-plugins-configure
line 112: "
line 113: " opts   -- a dictionary with the user supplied options for the bundle
line 114: " return -- a dictionary with the user supplied options for the bundle, this
line 115: "           will be merged with a s:bundle object into one dictionary.
line 116: " ---------------------------------------------------------------------------
line 117: func! s:parse_options(opts)
line 127: 
line 128: 
line 129: " ---------------------------------------------------------------------------
line 130: " Parse the plugin specification.  Corresponding documentation:
line 131: " vundle-plugins-uris
line 132: "
line 133: " arg    -- the string supplied to identify the plugin
line 134: " return -- a dictionary with the folder name (key 'name') and the uri (key
line 135: "           'uri') for cloning the plugin  and the original argument (key
line 136: "           'name_spec')
line 137: " ---------------------------------------------------------------------------
line 138: func! s:parse_name(arg)
line 160: 
line 161: 
line 162: " ---------------------------------------------------------------------------
line 163: "  Modify the runtimepath, after all bundles have been added, so that the
line 164: "  directories that were in the default runtimepath appear first in the list
line 165: "  (with their 'after' directories last).
line 166: " ---------------------------------------------------------------------------
line 167: func! s:rtp_add_defaults()
line 179: 
line 180: 
line 181: " ---------------------------------------------------------------------------
line 182: " Remove all paths for the plugins which are managed by Vundle from the
line 183: " runtimepath.
line 184: " ---------------------------------------------------------------------------
line 185: func! s:rtp_rm_a()
line 192: 
line 193: 
line 194: " ---------------------------------------------------------------------------
line 195: " Add all paths for the plugins which are managed by Vundle to the
line 196: " runtimepath.
line 197: " ---------------------------------------------------------------------------
line 198: func! s:rtp_add_a()
line 205: 
line 206: 
line 207: " ---------------------------------------------------------------------------
line 208: " Remove a directory and the corresponding 'after' directory from runtimepath.
line 209: "
line 210: " dir    -- the directory name to be removed as a string.  The corresponding
line 211: "           'after' directory will also be removed.
line 212: " ---------------------------------------------------------------------------
line 213: func! s:rtp_rm(dir) abort
line 217: 
line 218: 
line 219: " ---------------------------------------------------------------------------
line 220: " Add a directory and the corresponding 'after' directory to runtimepath.
line 221: "
line 222: " dir    -- the directory name to be added as a string.  The corresponding
line 223: "           'after' directory will also be added.
line 224: " ---------------------------------------------------------------------------
line 225: func! s:rtp_add(dir) abort
line 229: 
line 230: 
line 231: " ---------------------------------------------------------------------------
line 232: " Expand and simplify a path.
line 233: "
line 234: " path   -- the path to expand as a string
line 235: " return -- the expanded and simplified path
line 236: " ---------------------------------------------------------------------------
line 237: func! s:expand_path(path) abort
line 240: 
line 241: 
line 242: " ---------------------------------------------------------------------------
line 243: " Find the actual path inside a bundle directory to be added to the
line 244: " runtimepath.  It might be provided by the user with the 'rtp' option.
line 245: " Corresponding documentation: vundle-plugins-configure
line 246: "
line 247: " opts   -- a bundle dict
line 248: " return -- expanded path to the corresponding plugin directory
line 249: " ---------------------------------------------------------------------------
line 250: func! s:rtpath(opts)
line 253: 
line 254: 
line 255: " ---------------------------------------------------------------------------
line 256: " a bundle 'object'
line 257: " ---------------------------------------------------------------------------
line 258: let s:bundle = {}
line 259: 
line 260: 
line 261: " ---------------------------------------------------------------------------
line 262: " Return the absolute path to the directory inside the bundle directory
line 263: " (prefix) where thr bundle will be cloned.
line 264: "
line 265: " return -- the target location to clone this bundle to
line 266: " ---------------------------------------------------------------------------
line 267: func! s:bundle.path()
line 270: 
line 271: 
line 272: " ---------------------------------------------------------------------------
line 273: "  Determine if the bundle has the pinned attribute set in the config
line 274: "
line 275: "  return -- 1 if the bundle is pinned, 0 otherwise
line 276: " ---------------------------------------------------------------------------
line 277: func! s:bundle.is_pinned()
line 280: 
line 281: " vim: set expandtab sts=2 ts=2 sw=2 tw=78 norl:
finished sourcing /home/burp/.vim/bundle/Vundle.vim/autoload/vundle/config.vim
continuing in vundle#rc
calling vundle#config#init()

line 1:   if !exists('g:vundle#bundles') | let g:vundle#bundles = [] | endif
line 1:  let g:vundle#bundles = [] | endif
line 1:  endif
line 2:   call s:rtp_rm_a()
calling <SNR>17_rtp_rm_a()

line 1:   let paths = map(copy(g:vundle#bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp-='.fnameescape(prepends)
line 4: set rtp-=
line 5:   exec 'set rtp-='.fnameescape(appends)
line 5: set rtp-=/after
<SNR>17_rtp_rm_a returning #0

continuing in vundle#config#init

line 3:   let g:vundle#bundles = []
line 4:   let s:bundle_names = {}
vundle#config#init returning #0

continuing in vundle#rc

vundle#rc returning #0

continuing in vundle#begin

vundle#begin returning #0

continuing in /home/burp/.config/nvim/init.vim

line 23: 
line 24: " let Vundle manage Vundle, required
line 25: Plugin 'VundleVim/Vundle.vim'
line 25: call vundle#config#bundle('VundleVim/Vundle.vim')
calling vundle#config#bundle('VundleVim/Vundle.vim')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling vundle#config#init_bundle('VundleVim/Vundle.vim', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling <SNR>17_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
<SNR>17_parse_options returning {}

continuing in vundle#config#init_bundle

calling <SNR>17_parse_name('VundleVim/Vundle.vim')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
<SNR>17_parse_name returning {'uri': 'https://github.com/VundleVim/...', 'name_spec': 'VundleVim/Vundle.vim'}

continuing in vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling <SNR>17_rtpath({'uri': 'https://github.com/VundleVim/...Vim/Vundle.vim', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling 1()

line 1:   return s:expand_path(g:vundle#bundle_dir.'/') . self.name
calling <SNR>17_expand_path('/home/burp/.vim/bundle/')

line 1:   return simplify(expand(a:path, 1))
<SNR>17_expand_path returning '/home/burp/.vim/bundle/'

continuing in 1

1 returning '/home/burp/.vim/bundle/Vundle.vim'

continuing in <SNR>17_rtpath

<SNR>17_rtpath returning '/home/burp/.vim/bundle/Vundle.vim'

continuing in vundle#config#init_bundle

line 7:   return b
vundle#config#init_bundle returning {'uri': 'https://github.com/VundleVim/...Vim/Vundle.vim', 'path': function('1')}

continuing in vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling <SNR>17_check_bundle_name({'uri': 'https://github.com/VundleVim/...Vim/Vundle.vim', 'path': function('1')})

line 1:   if has_key(s:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . s:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   elseif a:bundle.name !~ '\v^[A-Za-z0-9_-]%(\.?[A-Za-z0-9_-])*$'
line 8:     echoerr 'Invalid plugin name: ' . a:bundle.name
line 9:     return 0
line 10:   endif
line 11:   let s:bundle_names[a:bundle.name] = a:bundle.name_spec
line 12:   return 1
<SNR>17_check_bundle_name returning #1

continuing in vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle#lazy_load') && g:vundle#lazy_load
line 6:     call add(g:vundle#bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:vundle#bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
vundle#config#bundle returning {'uri': 'https://github.com/VundleVim/...Vim/Vundle.vim', 'path': function('1')}

continuing in /home/burp/.config/nvim/init.vim

line 26: 
line 27: "Autocompletion plugin from git
line 28: Plugin 'ycm-core/YouCompleteMe'
line 28: call vundle#config#bundle('ycm-core/YouCompleteMe')
calling vundle#config#bundle('ycm-core/YouCompleteMe')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling vundle#config#init_bundle('ycm-core/YouCompleteMe', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling <SNR>17_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
<SNR>17_parse_options returning {}

continuing in vundle#config#init_bundle

calling <SNR>17_parse_name('ycm-core/YouCompleteMe')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
<SNR>17_parse_name returning {'uri': 'https://github.com/ycm-core/Y... 'name_spec': 'ycm-core/YouCompleteMe'}

continuing in vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling <SNR>17_rtpath({'uri': 'https://github.com/ycm-core/Y.../YouCompleteMe', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling 1()

line 1:   return s:expand_path(g:vundle#bundle_dir.'/') . self.name
calling <SNR>17_expand_path('/home/burp/.vim/bundle/')

line 1:   return simplify(expand(a:path, 1))
<SNR>17_expand_path returning '/home/burp/.vim/bundle/'

continuing in 1

1 returning '/home/burp/.vim/bundle/YouCompleteMe'

continuing in <SNR>17_rtpath

<SNR>17_rtpath returning '/home/burp/.vim/bundle/YouCompleteMe'

continuing in vundle#config#init_bundle

line 7:   return b
vundle#config#init_bundle returning {'uri': 'https://github.com/ycm-core/Y.../YouCompleteMe', 'path': function('1')}

continuing in vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling <SNR>17_check_bundle_name({'uri': 'https://github.com/ycm-core/Y.../YouCompleteMe', 'path': function('1')})

line 1:   if has_key(s:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . s:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   elseif a:bundle.name !~ '\v^[A-Za-z0-9_-]%(\.?[A-Za-z0-9_-])*$'
line 8:     echoerr 'Invalid plugin name: ' . a:bundle.name
line 9:     return 0
line 10:   endif
line 11:   let s:bundle_names[a:bundle.name] = a:bundle.name_spec
line 12:   return 1
<SNR>17_check_bundle_name returning #1

continuing in vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle#lazy_load') && g:vundle#lazy_load
line 6:     call add(g:vundle#bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:vundle#bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
vundle#config#bundle returning {'uri': 'https://github.com/ycm-core/Y.../YouCompleteMe', 'path': function('1')}

continuing in /home/burp/.config/nvim/init.vim

line 29: 
line 30: "Git plugin, ironically also from git
line 31: Plugin 'tpope/vim-fugitive'
line 31: call vundle#config#bundle('tpope/vim-fugitive')
calling vundle#config#bundle('tpope/vim-fugitive')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling vundle#config#init_bundle('tpope/vim-fugitive', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling <SNR>17_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
<SNR>17_parse_options returning {}

continuing in vundle#config#init_bundle

calling <SNR>17_parse_name('tpope/vim-fugitive')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
<SNR>17_parse_name returning {'uri': 'https://github.com/tpope/vim-...ve', 'name_spec': 'tpope/vim-fugitive'}

continuing in vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling <SNR>17_rtpath({'uri': 'https://github.com/tpope/vim-...e/vim-fugitive', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling 1()

line 1:   return s:expand_path(g:vundle#bundle_dir.'/') . self.name
calling <SNR>17_expand_path('/home/burp/.vim/bundle/')

line 1:   return simplify(expand(a:path, 1))
<SNR>17_expand_path returning '/home/burp/.vim/bundle/'

continuing in 1

1 returning '/home/burp/.vim/bundle/vim-fugitive'

continuing in <SNR>17_rtpath

<SNR>17_rtpath returning '/home/burp/.vim/bundle/vim-fugitive'

continuing in vundle#config#init_bundle

line 7:   return b
vundle#config#init_bundle returning {'uri': 'https://github.com/tpope/vim-...e/vim-fugitive', 'path': function('1')}

continuing in vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling <SNR>17_check_bundle_name({'uri': 'https://github.com/tpope/vim-...e/vim-fugitive', 'path': function('1')})

line 1:   if has_key(s:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . s:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   elseif a:bundle.name !~ '\v^[A-Za-z0-9_-]%(\.?[A-Za-z0-9_-])*$'
line 8:     echoerr 'Invalid plugin name: ' . a:bundle.name
line 9:     return 0
line 10:   endif
line 11:   let s:bundle_names[a:bundle.name] = a:bundle.name_spec
line 12:   return 1
<SNR>17_check_bundle_name returning #1

continuing in vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle#lazy_load') && g:vundle#lazy_load
line 6:     call add(g:vundle#bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:vundle#bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
vundle#config#bundle returning {'uri': 'https://github.com/tpope/vim-...e/vim-fugitive', 'path': function('1')}

continuing in /home/burp/.config/nvim/init.vim

line 32: 
line 33: "vim-tmux-navigator, smart navigation between vim and tmux panes
line 34: Plugin 'christoomey/vim-tmux-navigator'
line 34: call vundle#config#bundle('christoomey/vim-tmux-navigator')
calling vundle#config#bundle('christoomey/vim-tmux-navigator')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling vundle#config#init_bundle('christoomey/vim-tmux-navigator', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling <SNR>17_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
<SNR>17_parse_options returning {}

continuing in vundle#config#init_bundle

calling <SNR>17_parse_name('christoomey/vim-tmux-navigator')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
<SNR>17_parse_name returning {'uri': 'https://github.com/christoome...pec': 'christoomey/vim-tmux-navigator'}

continuing in vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling <SNR>17_rtpath({'uri': 'https://github.com/christoome...tmux-navigator', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling 1()

line 1:   return s:expand_path(g:vundle#bundle_dir.'/') . self.name
calling <SNR>17_expand_path('/home/burp/.vim/bundle/')

line 1:   return simplify(expand(a:path, 1))
<SNR>17_expand_path returning '/home/burp/.vim/bundle/'

continuing in 1

1 returning '/home/burp/.vim/bundle/vim-tmux-navigator'

continuing in <SNR>17_rtpath

<SNR>17_rtpath returning '/home/burp/.vim/bundle/vim-tmux-navigator'

continuing in vundle#config#init_bundle

line 7:   return b
vundle#config#init_bundle returning {'uri': 'https://github.com/christoome...tmux-navigator', 'path': function('1')}

continuing in vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling <SNR>17_check_bundle_name({'uri': 'https://github.com/christoome...tmux-navigator', 'path': function('1')})

line 1:   if has_key(s:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . s:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   elseif a:bundle.name !~ '\v^[A-Za-z0-9_-]%(\.?[A-Za-z0-9_-])*$'
line 8:     echoerr 'Invalid plugin name: ' . a:bundle.name
line 9:     return 0
line 10:   endif
line 11:   let s:bundle_names[a:bundle.name] = a:bundle.name_spec
line 12:   return 1
<SNR>17_check_bundle_name returning #1

continuing in vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle#lazy_load') && g:vundle#lazy_load
line 6:     call add(g:vundle#bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:vundle#bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
vundle#config#bundle returning {'uri': 'https://github.com/christoome...tmux-navigator', 'path': function('1')}

continuing in /home/burp/.config/nvim/init.vim

line 35: 
line 36: " All of your Plugins must be added before the following line
line 37: call vundle#end()            " required
calling vundle#end()

line 1:   unlet g:vundle#lazy_load
line 2:   call vundle#config#activate_bundles()
calling vundle#config#activate_bundles()

line 1:   call s:rtp_add_a()
calling <SNR>17_rtp_add_a()

line 1:   let paths = map(copy(g:vundle#bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp^='.fnameescape(prepends)
line 4: set rtp^=/home/burp/.vim/bundle/Vundle.vim,/home/burp/.vim/bundle/YouCompleteMe,/home/burp/.vim/bundle/vim-fugitive,/home/burp/.vim/bundle/vim-tmux-navigator
line 5:   exec 'set rtp+='.fnameescape(appends)
line 5: set rtp+=/home/burp/.vim/bundle/Vundle.vim/after,/home/burp/.vim/bundle/YouCompleteMe/after,/home/burp/.vim/bundle/vim-fugitive/after,/home/burp/.vim/bundle/vim-tmux-navigator/after
<SNR>17_rtp_add_a returning #0

continuing in vundle#config#activate_bundles

line 2:   call s:rtp_add_defaults()
calling <SNR>17_rtp_add_defaults()

line 1:   let current = &rtp
line 2:   set rtp&vim
line 3:   let default = &rtp
line 4:   let &rtp = current
line 5:   let default_rtp_items = split(default, ',')
line 6:   if !empty(default_rtp_items)
line 7:     let first_item = fnameescape(default_rtp_items[0])
line 8:     exec 'set rtp-=' . first_item
line 8: set rtp-=/home/burp/.config/nvim
line 9:     exec 'set rtp^=' . first_item
line 9: set rtp^=/home/burp/.config/nvim
line 10:   endif
<SNR>17_rtp_add_defaults returning #0

continuing in vundle#config#activate_bundles

vundle#config#activate_bundles returning #0

continuing in vundle#end

vundle#end returning #0

continuing in /home/burp/.config/nvim/init.vim

line 38: filetype plugin indent on    " required
Searching for "filetype.lua filetype.vim" in runtime path
Searching for "/home/burp/.config/nvim/filetype.lua"
Searching for "/home/burp/.config/nvim/filetype.vim"
Searching for "/home/burp/.vim/bundle/Vundle.vim/filetype.lua"
Searching for "/home/burp/.vim/bundle/Vundle.vim/filetype.vim"
Searching for "/home/burp/.vim/bundle/YouCompleteMe/filetype.lua"
Searching for "/home/burp/.vim/bundle/YouCompleteMe/filetype.vim"
Searching for "/home/burp/.vim/bundle/vim-fugitive/filetype.lua"
Searching for "/home/burp/.vim/bundle/vim-fugitive/filetype.vim"
Searching for "/home/burp/.vim/bundle/vim-tmux-navigator/filetype.lua"
Searching for "/home/burp/.vim/bundle/vim-tmux-navigator/filetype.vim"
Searching for "/etc/xdg/nvim/filetype.lua"
Searching for "/etc/xdg/nvim/filetype.vim"
Searching for "/usr/share/nvim/runtime/filetype.lua"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime)
chdir(/home/burp/Applications/.bash_aliases)
line 38: sourcing "/usr/share/nvim/runtime/filetype.lua"
finished sourcing /usr/share/nvim/runtime/filetype.lua
continuing in /home/burp/.config/nvim/init.vim
Searching for "/usr/share/nvim/runtime/filetype.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime)
chdir(/home/burp/Applications/.bash_aliases)
line 38: sourcing "/usr/share/nvim/runtime/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2022 Sep 27
line 5: 
line 6: " Only run this if enabled
line 7: if !exists("do_legacy_filetype")
line 8:   finish
finished sourcing /usr/share/nvim/runtime/filetype.vim
continuing in /home/burp/.config/nvim/init.vim
Searching for "/usr/lib/nvim/filetype.lua"
Searching for "/usr/lib/nvim/filetype.vim"
Searching for "/usr/share/vim/vimfiles/filetype.lua"
Searching for "/usr/share/vim/vimfiles/filetype.vim"
Searching for "ftplugin.vim" in runtime path
Searching for "/home/burp/.config/nvim/ftplugin.vim"
Searching for "/home/burp/.vim/bundle/Vundle.vim/ftplugin.vim"
Searching for "/home/burp/.vim/bundle/YouCompleteMe/ftplugin.vim"
Searching for "/home/burp/.vim/bundle/vim-fugitive/ftplugin.vim"
Searching for "/home/burp/.vim/bundle/vim-tmux-navigator/ftplugin.vim"
Searching for "/etc/xdg/nvim/ftplugin.vim"
Searching for "/usr/share/nvim/runtime/ftplugin.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime)
chdir(/home/burp/Applications/.bash_aliases)
line 38: sourcing "/usr/share/nvim/runtime/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2006 Apr 30
line 5: 
line 6: if exists("did_load_ftplugin")
line 7:   finish
finished sourcing /usr/share/nvim/runtime/ftplugin.vim
continuing in /home/burp/.config/nvim/init.vim
Searching for "/usr/lib/nvim/ftplugin.vim"
Searching for "/usr/share/vim/vimfiles/ftplugin.vim"
Searching for "indent.vim" in runtime path
Searching for "/home/burp/.config/nvim/indent.vim"
Searching for "/home/burp/.vim/bundle/Vundle.vim/indent.vim"
Searching for "/home/burp/.vim/bundle/YouCompleteMe/indent.vim"
Searching for "/home/burp/.vim/bundle/vim-fugitive/indent.vim"
Searching for "/home/burp/.vim/bundle/vim-tmux-navigator/indent.vim"
Searching for "/etc/xdg/nvim/indent.vim"
Searching for "/usr/share/nvim/runtime/indent.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime)
chdir(/home/burp/Applications/.bash_aliases)
line 38: sourcing "/usr/share/nvim/runtime/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2008 Feb 22
line 5: 
line 6: if exists("did_indent_on")
line 7:   finish
finished sourcing /usr/share/nvim/runtime/indent.vim
continuing in /home/burp/.config/nvim/init.vim
Searching for "/usr/lib/nvim/indent.vim"
Searching for "/usr/share/vim/vimfiles/indent.vim"
line 39: "------------------------------------------------------------
line 40: 
line 41: "Fix python3 interpreter
line 42: let g:python3_host_prog = '/usr/bin/python3'
line 43: let g:ycm_path_to_python_interpreter = '/usr/bin/python3'
line 44: 
line 45: " These are highly recommended options.
line 46: 
line 47: " Vim with default settings does not allow easy switching between multiple files
line 48: " in the same editor window. Users can use multiple split windows or multiple
line 49: " tab pages to edit multiple files, but it is still best to enable an option to
line 50: " allow easier switching between files.
line 51: "
line 52: " One such option is the 'hidden' option, which allows you to re-use the same
line 53: " window and switch from an unsaved buffer without saving it first. Also allows
line 54: " you to keep an undo history for multiple files when re-using the same window
line 55: " in this way. Note that using persistent undo also lets you undo in multiple
line 56: " files even in the same window, but is less efficient and is actually designed
line 57: " for keeping undo history after closing Vim entirely. Vim will complain if you
line 58: " try to quit without saving, and swap files will keep you safe if your computer
line 59: " crashes.
line 60: set hidden
line 61: 
line 62: " Note that not everyone likes working this way (with the hidden option).
line 63: " Alternatives include using tabs or split windows instead of re-using the same
line 64: " window as mentioned above, and/or either of the following options:
line 65: " set confirm
line 66: " set autowriteall
line 67: 
line 68: " Better command-line completion
line 69: set wildmenu
line 70: 
line 71: " Show partial commands in the last line of the screen
line 72: set showcmd
line 73: 
line 74: " Highlight searches (use <C-L> to temporarily turn off highlighting; see the
line 75: " mapping of <C-L> below)
line 76: set hlsearch
line 77: 
line 78: "------------------------------------------------------------
line 79: "
line 80: " These are options that users frequently set in their .vimrc. Some of them
line 81: " change Vim's behaviour in ways which deviate from the true Vi way, but
line 82: " which are considered to add usability. Which, if any, of these options to
line 83: " use is very much a personal preference, but they are harmless.
line 84: 
line 85: " Use case insensitive search, except when using capital letters
line 86: set ignorecase
line 87: set smartcase
line 88: 
line 89: " Allow backspacing over autoindent, line breaks and start of insert action
line 90: set backspace=indent,eol,start
line 91: 
line 92: " When opening a new line and no filetype-specific indenting is enabled, keep
line 93: " the same indent as the line you're currently on. Useful for READMEs, etc.
line 94: set autoindent
line 95: 
line 96: " Stop certain movements from always going to the first character of a line.
line 97: " While this behaviour deviates from that of Vi, it does what most users
line 98: " coming from other editors would expect.
line 99: "set nostartofline
line 100: 
line 101: " Display the cursor position on the last line of the screen or in the status
line 102: " line of a window
line 103: set ruler
line 104: 
line 105: " Always display the status line, even if only one window is displayed
line 106: "set laststatus=2
line 107: 
line 108: " Instead of failing a command because of unsaved changes, instead raise a
line 109: " dialogue asking if you wish to save changed files.
line 110: set confirm
line 111: 
line 112: " Use visual bell instead of beeping when doing something wrong
line 113: set visualbell
line 114: 
line 115: " And reset the terminal code for the visual bell. If visualbell is set, and
line 116: " this line is also included, vim will neither flash nor beep. If visualbell
line 117: " is unset, this does nothing.
line 118: set t_vb=
line 119: 
line 120: " Enable use of the mouse for all modes
line 121: set mouse=a
line 122: 
line 123: " Set the command window height to 2 lines, to avoid many cases of having to
line 124: " "press <Enter> to continue"
line 125: set cmdheight=2
line 126: 
line 127: " Display line numbers on the left
line 128: set number
line 129: 
line 130: "Always wrap long lines
line 131: set wrap
line 132: 
line 133: " Quickly time out on keycodes, but never time out on mappings
line 134: set notimeout ttimeout ttimeoutlen=200
line 135: 
line 136: " Use <F9> to toggle between 'paste' and 'nopaste'
line 137: set pastetoggle=<F9>
line 138: 
line 139: "------------------------------------------------------------
line 140: 
line 141: " Indentation settings according to personal preference.
line 142: 
line 143: " Indentation settings for using 4 spaces instead of tabs.
line 144: " Do not change 'tabstop' from its default value of 8 with this setup.
line 145: set shiftwidth=4
line 146: set softtabstop=4
line 147: set expandtab
line 148: "set tabstop=4
line 149: 
line 150: "------------------------------------------------------------
line 151: " Useful mappings
line 152: "
line 153: 
line 154: " vim tmux navigator integrator
line 155: let mapleader = "\<Space>"
line 156: 
line 157: let g:tmux_navigator_no_mappings = 1
line 158: noremap <silent> <C-Left> :<C-U>TmuxNavigateLeft<cr>
line 159: noremap <silent> <C-Down> :<C-U>TmuxNavigateDown<cr>
line 160: noremap <silent> <C-Up> :<C-U>TmuxNavigateUp<cr>
line 161: noremap <silent> <C-Right> :<C-U>TmuxNavigateRight<cr>
line 162: "noremap <silent> <C-²> :<C-U>TmuxNavigatePrevious<cr>
line 163: 
line 164: " Reload init.vim
line 165: map :r :source $MYVIMRC
line 166: 
line 167: " CTRL-A  N  CTRL-A^Iadd N to the number at or after the cursor
line 168: " CTRL-X  N  CTRL-X^Isubtract N from the number at or after the cursor
line 169: " mapping them to + And  - 
line 170: nnoremap + <C-a>
line 171: nnoremap - <C-x>
line 172: vnoremap + <C-a>
line 173: vnoremap - <C-x>
line 174: 
line 175: "Map Shift to visual mode from normal mode
line 176: nnoremap <C-S>  

                          No mapping found
line 177: 
line 178: " Enter -> newline without entering insert mode
line 179: nnoremap <Enter> o<Esc>0"_U
line 180: 
line 181: " Move lines while holding shift
line 182: " Multiple lines => select in visual mode
line 183: nnoremap <S-M-Down> :m .+2<CR>==
line 184: nnoremap <S-M-Up> :m .-2<CR>==
line 185: inoremap <S-M-Down> <Esc>:m .+1<CR>==gi
line 186: inoremap <S-M-Up> <Esc>:m .-2<CR>==gi
line 187: vnoremap <S-M-Down> :m '>+1<CR>gv=gv
line 188: vnoremap <S-M-Up> :m '<-2<CR>gv=gv
line 189: 
line 190: " Ctrl-o is mapped to nth older iposition in jump list
line 191: " Ctrl-i is mapped to nth newer position in jump list
line 192: " Quickly insert an empty new line without entering insert modef
line 193: " nnoremap <Leader>o o<Esc>0"_D
line 194: " nnoremap <Leader>O O<Esc>0"_D
line 195: 
line 196: " unnamedplus^IA variant of the "unnamed" flag which uses the
line 197: " clipboard register "+" (quoteplus) instead of
line 198: " register "*" for all yank, delete, change and put
line 199: " operations which would normally go to the unnamed
line 200: " register.
line 201: 
line 202: " Ctrl - z is -> undo instead of stop 
line 203: nnoremap <C-z> :u <Enter>
line 204: vnoremap <C-z> <Esc> :u <Enter> <CR>==gv 
line 205: inoremap <C-z> <Esc> :u <Enter> <CR>==gi
line 206: 
line 207: " Normal clipboard functionality for yy, y and d
line 208: set clipboard+=unnamedplus
line 209: 
line 210: "nnoremap <C-c> yy
line 211: "nnoremap <C-v> p
line 212: "inoremap <C-c> <Esc> yy <CR>==gi
line 213: "inoremap <C-v> <Esc> p <CR>==gi
line 214: "vnoremap <C-c> y 
line 215: "vnoremap <C-v> p 
line 216: 
line 217: " C-x -> Escape
line 218: " inoremap <C-x> <Esc>
line 219: " vnoremap <C-x> <Esc>
line 220: 
line 221: " C-s => Save
line 222: nnoremap <C-s> :write! <Enter>
line 223: inoremap <C-s> <Esc> :write! <Enter> <CR>==gi
line 224: vnoremap <C-s> <Esc> :write! <Enter> <CR>==gv
line 225: 
line 226: " C-q => Quit
line 227: nnoremap <C-q> :q! <Enter>
line 228: inoremap <C-q> <Esc> :q! <Enter> <CR>==gi
line 229: vnoremap <C-q> <Esc> :q! <Enter> <CR>==gv
line 230: 
line 231: " C-w => Save and quit
line 232: " nnoremap <C-w> :wq<CR>
finished sourcing /home/burp/.config/nvim/init.vim
Searching for "plugin/**/*.vim" in "/home/burp/.config/nvim,/home/burp/.vim/bundle/Vundle.vim,/home/burp/.vim/bundle/YouCompleteMe,/home/burp/.vim/bundle/vim-fugitive,/home/burp/.vim/bundle/vim-tmux-navigator,/etc/xdg/nvim,/home/burp/.local/share/nvim/site,/usr/local/share/nvim/site,/usr/share/nvim/site,/usr/share/nvim/runtime,/usr/lib/nvim,/usr/share/nvim/site/after,/usr/local/share/nvim/site/after,/home/burp/.local/share/nvim/site/after,/etc/xdg/nvim/after,/home/burp/.config/nvim/after,/usr/share/vim/vimfiles,/home/burp/.vim/bundle/Vundle.vim,/home/burp/.vim/bundle/Vundle.vim/after,/home/burp/.vim/bundle/YouCompleteMe/after,/home/burp/.vim/bundle/vim-fugitive/after,/home/burp/.vim/bundle/vim-tmux-navigator/after"
Searching for "/home/burp/.config/nvim/plugin/**/*.vim"
Searching for "/home/burp/.vim/bundle/Vundle.vim/plugin/**/*.vim"
Searching for "/home/burp/.vim/bundle/YouCompleteMe/plugin/**/*.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/.vim/bundle/YouCompleteMe/plugin)
chdir(/home/burp/Applications/.bash_aliases)
sourcing "/home/burp/.vim/bundle/YouCompleteMe/plugin/youcompleteme.vim"
line 1: " Copyright (C) 2011, 2012  Google Inc.
line 2: "
line 3: " This file is part of YouCompleteMe.
line 4: "
line 5: " YouCompleteMe is free software: you can redistribute it and/or modify
line 6: " it under the terms of the GNU General Public License as published by
line 7: " the Free Software Foundation, either version 3 of the License, or
line 8: " (at your option) any later version.
line 9: "
line 10: " YouCompleteMe is distributed in the hope that it will be useful,
line 11: " but WITHOUT ANY WARRANTY; without even the implied warranty of
line 12: " MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
line 13: " GNU General Public License for more details.
line 14: "
line 15: " You should have received a copy of the GNU General Public License
line 16: " along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.
line 17: 
line 18: " This is basic vim plugin boilerplate
line 19: let s:save_cpo = &cpo
line 20: set cpo&vim
line 21: 
line 22: function! s:restore_cpo()
line 26: 
line 27: " NOTE: The minimum supported version is 8.1.2269, but neovim always reports as
line 28: " v:version 800, but will largely work.
line 29: let s:is_neovim = has( 'nvim' )
line 30: 
line 31: if exists( "g:loaded_youcompleteme" )
line 32:   call s:restore_cpo()
line 33:   finish
line 34: elseif ( v:version < 801 || (v:version == 801 && !has( 'patch2269' )) ) && !s:is_neovim
line 36:   echohl WarningMsg | echomsg "YouCompleteMe unavailable: requires Vim 8.1.2269+." | echohl None
line 36:  echomsg "YouCompleteMe unavailable: requires Vim 8.1.2269+." | echohl None
line 36:  echohl None
line 39:   call s:restore_cpo()
line 40:   finish
line 41: elseif !has( 'timers' )
line 42:   echohl WarningMsg | echomsg "YouCompleteMe unavailable: requires Vim compiled with " . "the timers feature." | echohl None
line 42:  echomsg "YouCompleteMe unavailable: requires Vim compiled with " . "the timers feature." | echohl None
line 42:  echohl None
line 46:   call s:restore_cpo()
line 47:   finish
line 48: elseif !has( 'python3_compiled' )
Searching for "autoload/provider/python3.vim" in runtime path
Searching for "/home/burp/.config/nvim/autoload/provider/python3.vim"
Searching for "/home/burp/.vim/bundle/Vundle.vim/autoload/provider/python3.vim"
Searching for "/home/burp/.vim/bundle/YouCompleteMe/autoload/provider/python3.vim"
Searching for "/home/burp/.vim/bundle/vim-fugitive/autoload/provider/python3.vim"
Searching for "/home/burp/.vim/bundle/vim-tmux-navigator/autoload/provider/python3.vim"
Searching for "/etc/xdg/nvim/autoload/provider/python3.vim"
Searching for "/usr/share/nvim/runtime/autoload/provider/python3.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/autoload/provider)
chdir(/home/burp/Applications/.bash_aliases)
line 48: sourcing "/usr/share/nvim/runtime/autoload/provider/python3.vim"
line 1: " The Python3 provider uses a Python3 host to emulate an environment for running
line 2: " python3 plugins. :help provider
line 3: "
line 4: " Associating the plugin with the Python3 host is the first step because
line 5: " plugins will be passed as command-line arguments
line 6: 
line 7: if exists('g:loaded_python3_provider')
line 8:   finish
line 9: endif
line 10: let [s:prog, s:err] = provider#pythonx#Detect(3)
Searching for "autoload/provider/pythonx.vim" in runtime path
Searching for "/home/burp/.config/nvim/autoload/provider/pythonx.vim"
Searching for "/home/burp/.vim/bundle/Vundle.vim/autoload/provider/pythonx.vim"
Searching for "/home/burp/.vim/bundle/YouCompleteMe/autoload/provider/pythonx.vim"
Searching for "/home/burp/.vim/bundle/vim-fugitive/autoload/provider/pythonx.vim"
Searching for "/home/burp/.vim/bundle/vim-tmux-navigator/autoload/provider/pythonx.vim"
Searching for "/etc/xdg/nvim/autoload/provider/pythonx.vim"
Searching for "/usr/share/nvim/runtime/autoload/provider/pythonx.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/autoload/provider)
chdir(/home/burp/Applications/.bash_aliases)
line 10: sourcing "/usr/share/nvim/runtime/autoload/provider/pythonx.vim"
line 1: " The Python provider helper
line 2: if exists('s:loaded_pythonx_provider')
line 3:   finish
line 4: endif
line 5: 
line 6: let s:loaded_pythonx_provider = 1
line 7: 
line 8: function! provider#pythonx#Require(host) abort
line 22: 
line 23: function! s:get_python_executable_from_host_var(major_version) abort
line 26: 
line 27: function! s:get_python_candidates(major_version) abort
line 32: 
line 33: " Returns [path_to_python_executable, error_message]
line 34: function! provider#pythonx#Detect(major_version) abort
line 37: 
line 38: " Returns [path_to_python_executable, error_message]
line 39: function! provider#pythonx#DetectByModule(module, major_version) abort
line 61: 
line 62: " Returns array: [prog_exitcode, prog_version]
line 63: function! s:import_module(prog, module) abort
line 73: 
line 74: " Returns array: [was_success, error_message]
line 75: function! provider#pythonx#CheckForModule(prog, module, major_version) abort
finished sourcing /usr/share/nvim/runtime/autoload/provider/pythonx.vim
continuing in /usr/share/nvim/runtime/autoload/provider/python3.vim
calling provider#pythonx#Detect(3)

line 1:   return provider#pythonx#DetectByModule('neovim', a:major_version)
calling provider#pythonx#DetectByModule('neovim', 3)

line 1:   let python_exe = s:get_python_executable_from_host_var(a:major_version)
calling <SNR>20_get_python_executable_from_host_var(3)

line 1:   return expand(get(g:, 'python'.(a:major_version == 3 ? '3' : execute("throw 'unsupported'")).'_host_prog', ''), v:true)
<SNR>20_get_python_executable_from_host_var returning '/usr/bin/python3'

continuing in provider#pythonx#DetectByModule

line 2: 
line 3:   if !empty(python_exe)
line 4:     return [exepath(expand(python_exe, v:true)), '']
provider#pythonx#DetectByModule returning ['/usr/bin/python3', '']

continuing in provider#pythonx#Detect

provider#pythonx#Detect returning ['/usr/bin/python3', '']

continuing in /usr/share/nvim/runtime/autoload/provider/python3.vim

line 11: let g:loaded_python3_provider = empty(s:prog) ? 1 : 2
line 12: 
line 13: function! provider#python3#Prog() abort
line 16: 
line 17: function! provider#python3#Error() abort
line 20: 
line 21: " The Python3 provider plugin will run in a separate instance of the Python3
line 22: " host.
line 23: call remote#host#RegisterClone('legacy-python3-provider', 'python3')
Searching for "autoload/remote/host.vim" in runtime path
Searching for "/home/burp/.config/nvim/autoload/remote/host.vim"
Searching for "/home/burp/.vim/bundle/Vundle.vim/autoload/remote/host.vim"
Searching for "/home/burp/.vim/bundle/YouCompleteMe/autoload/remote/host.vim"
Searching for "/home/burp/.vim/bundle/vim-fugitive/autoload/remote/host.vim"
Searching for "/home/burp/.vim/bundle/vim-tmux-navigator/autoload/remote/host.vim"
Searching for "/etc/xdg/nvim/autoload/remote/host.vim"
Searching for "/usr/share/nvim/runtime/autoload/remote/host.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/autoload/remote)
chdir(/home/burp/Applications/.bash_aliases)
line 23: sourcing "/usr/share/nvim/runtime/autoload/remote/host.vim"
line 1: let s:hosts = {}
line 2: let s:plugin_patterns = {}
line 3: let s:plugins_for_host = {}
line 4: 
line 5: " Register a host by associating it with a factory(funcref)
line 6: function! remote#host#Register(name, pattern, factory) abort
line 14: 
line 15: " Register a clone to an existing host. The new host will use the same factory
line 16: " as `source`, but it will run as a different process. This can be used by
line 17: " plugins that should run isolated from other plugins created for the same host
line 18: " type
line 19: function! remote#host#RegisterClone(name, orig_name) abort
line 31: 
line 32: " Get a host channel, bootstrapping it if necessary
line 33: function! remote#host#Require(name) abort
line 48: 
line 49: function! remote#host#IsRunning(name) abort
line 55: 
line 56: " Example of registering a Python plugin with two commands (one async), one
line 57: " autocmd (async) and one function (sync):
line 58: "
line 59: " let s:plugin_path = expand('<sfile>:p:h').'/nvim_plugin.py'
line 60: " call remote#host#RegisterPlugin('python', s:plugin_path, [
line 61: "   \ {'type': 'command', 'name': 'PyCmd', 'sync': 1, 'opts': {}},
line 62: "   \ {'type': 'command', 'name': 'PyAsyncCmd', 'sync': 0, 'opts': {'eval': 'cursor()'}},
line 63: "   \ {'type': 'autocmd', 'name': 'BufEnter', 'sync': 0, 'opts': {'eval': 'expand("<afile>")'}},
line 64: "   \ {'type': 'function', 'name': 'PyFunc', 'sync': 1, 'opts': {}}
line 65: "   \ ])
line 66: "
line 67: " The third item in a declaration is a boolean: non zero means the command,
line 68: " autocommand or function will be executed synchronously with rpcrequest.
line 69: function! remote#host#RegisterPlugin(host, path, specs) abort
line 111: 
line 112: function! s:RegistrationCommands(host) abort
line 155: 
line 156: function! remote#host#UpdateRemotePlugins() abort
line 176: 
line 177: function! remote#host#PluginsForHost(host) abort
line 183: 
line 184: function! remote#host#LoadErrorForHost(host, log) abort
line 190: 
line 191: " Registration of standard hosts
line 192: 
line 193: " Python/Python3
line 194: call remote#host#Register('python', '*', function('provider#pythonx#Require'))
calling remote#host#Register('python', '*', function('provider#pythonx#Require'))

line 1:   let s:hosts[a:name] = {'factory': a:factory, 'channel': 0, 'initialized': 0}
line 2:   let s:plugin_patterns[a:name] = a:pattern
line 3:   if type(a:factory) == type(1) && a:factory
line 4:     " Passed a channel directly
line 5:     let s:hosts[a:name].channel = a:factory
line 6:   endif
remote#host#Register returning #0

continuing in /usr/share/nvim/runtime/autoload/remote/host.vim

line 196: call remote#host#Register('python3', '*', function('provider#pythonx#Require'))
calling remote#host#Register('python3', '*', function('provider#pythonx#Require'))

line 1:   let s:hosts[a:name] = {'factory': a:factory, 'channel': 0, 'initialized': 0}
line 2:   let s:plugin_patterns[a:name] = a:pattern
line 3:   if type(a:factory) == type(1) && a:factory
line 4:     " Passed a channel directly
line 5:     let s:hosts[a:name].channel = a:factory
line 6:   endif
remote#host#Register returning #0

continuing in /usr/share/nvim/runtime/autoload/remote/host.vim

line 198: 
line 199: " Ruby
line 200: call remote#host#Register('ruby', '*.rb', function('provider#ruby#Require'))
calling remote#host#Register('ruby', '*.rb', function('provider#ruby#Require'))

line 1:   let s:hosts[a:name] = {'factory': a:factory, 'channel': 0, 'initialized': 0}
line 2:   let s:plugin_patterns[a:name] = a:pattern
line 3:   if type(a:factory) == type(1) && a:factory
line 4:     " Passed a channel directly
line 5:     let s:hosts[a:name].channel = a:factory
line 6:   endif
remote#host#Register returning #0

continuing in /usr/share/nvim/runtime/autoload/remote/host.vim

line 202: 
line 203: " nodejs
line 204: call remote#host#Register('node', '*', function('provider#node#Require'))
calling remote#host#Register('node', '*', function('provider#node#Require'))

line 1:   let s:hosts[a:name] = {'factory': a:factory, 'channel': 0, 'initialized': 0}
line 2:   let s:plugin_patterns[a:name] = a:pattern
line 3:   if type(a:factory) == type(1) && a:factory
line 4:     " Passed a channel directly
line 5:     let s:hosts[a:name].channel = a:factory
line 6:   endif
remote#host#Register returning #0

continuing in /usr/share/nvim/runtime/autoload/remote/host.vim

line 206: 
line 207: " perl
line 208: call remote#host#Register('perl', '*', function('provider#perl#Require'))
calling remote#host#Register('perl', '*', function('provider#perl#Require'))

line 1:   let s:hosts[a:name] = {'factory': a:factory, 'channel': 0, 'initialized': 0}
line 2:   let s:plugin_patterns[a:name] = a:pattern
line 3:   if type(a:factory) == type(1) && a:factory
line 4:     " Passed a channel directly
line 5:     let s:hosts[a:name].channel = a:factory
line 6:   endif
remote#host#Register returning #0

continuing in /usr/share/nvim/runtime/autoload/remote/host.vim

finished sourcing /usr/share/nvim/runtime/autoload/remote/host.vim
continuing in /usr/share/nvim/runtime/autoload/provider/python3.vim
calling remote#host#RegisterClone('legacy-python3-provider', 'python3')

line 1:   if !has_key(s:hosts, a:orig_name)
line 2:     throw 'No host named "'.a:orig_name.'" is registered'
line 3:   endif
line 4:   let Factory = s:hosts[a:orig_name].factory
line 5:   let s:hosts[a:name] = { 'factory': Factory, 'channel': 0, 'initialized': 0, 'orig_name': a:orig_name }
remote#host#RegisterClone returning #0

continuing in /usr/share/nvim/runtime/autoload/provider/python3.vim

line 24: call remote#host#RegisterPlugin('legacy-python3-provider', 'script_host.py', [])
calling remote#host#RegisterPlugin('legacy-python3-provider', 'script_host.py', [])

line 1:   let plugins = remote#host#PluginsForHost(a:host)
calling remote#host#PluginsForHost('legacy-python3-provider')

line 1:   if !has_key(s:plugins_for_host, a:host)
line 2:     let s:plugins_for_host[a:host] = []
line 3:   end
line 4:   return s:plugins_for_host[a:host]
remote#host#PluginsForHost returning []

continuing in remote#host#RegisterPlugin

line 2: 
line 3:   for plugin in plugins
line 4:     if plugin.path == a:path
line 5:       throw 'Plugin "'.a:path.'" is already registered'
line 6:     endif
line 7:   endfor
line 8: 
line 9:   if has_key(s:hosts, a:host) && remote#host#IsRunning(a:host)
calling remote#host#IsRunning('legacy-python3-provider')

line 1:   if !has_key(s:hosts, a:name)
line 2:     throw 'No host named "'.a:name.'" is registered'
line 3:   endif
line 4:   return s:hosts[a:name].channel != 0
remote#host#IsRunning returning #0

continuing in remote#host#RegisterPlugin

line 10:     " For now we won't allow registration of plugins when the host is already
line 11:     " running.
line 12:     throw 'Host "'.a:host.'" is already running'
line 13:   endif
line 14: 
line 15:   for spec in a:specs
line 16:     let type = spec.type
line 17:     let name = spec.name
line 18:     let sync = spec.sync
line 19:     let opts = spec.opts
line 20:     let rpc_method = a:path
line 21:     if type == 'command'
line 22:       let rpc_method .= ':command:'.name
line 23:       call remote#define#CommandOnHost(a:host, rpc_method, sync, name, opts)
line 24:     elseif type == 'autocmd'
line 25:       " Since multiple handlers can be attached to the same autocmd event by a
line 26:       " single plugin, we need a way to uniquely identify the rpc method to
line 27:       " call.  The solution is to append the autocmd pattern to the method
line 28:       " name(This still has a limit: one handler per event/pattern combo, but
line 29:       " there's no need to allow plugins define multiple handlers in that case)
line 30:       let rpc_method .= ':autocmd:'.name.':'.get(opts, 'pattern', '*')
line 31:       call remote#define#AutocmdOnHost(a:host, rpc_method, sync, name, opts)
line 32:     elseif type == 'function'
line 33:       let rpc_method .= ':function:'.name
line 34:       call remote#define#FunctionOnHost(a:host, rpc_method, sync, name, opts)
line 35:     else
line 36:       echoerr 'Invalid declaration type: '.type
line 37:     endif
line 38:   endfor
line 39: 
line 40:   call add(plugins, {'path': a:path, 'specs': a:specs})
remote#host#RegisterPlugin returning #0

continuing in /usr/share/nvim/runtime/autoload/provider/python3.vim

line 25: 
line 26: function! provider#python3#Call(method, args) abort
finished sourcing /usr/share/nvim/runtime/autoload/provider/python3.vim
continuing in /home/burp/.vim/bundle/YouCompleteMe/plugin/youcompleteme.vim
line 49:   echohl WarningMsg | echomsg "YouCompleteMe unavailable: requires Vim compiled with " . "Python (3.8.0+) support." | echohl None
line 49:  echomsg "YouCompleteMe unavailable: requires Vim compiled with " . "Python (3.8.0+) support." | echohl None
line 49:  echohl None
line 53:   call s:restore_cpo()
line 54:   finish
line 55: " These calls try to load the Python 3 libraries when Vim is
line 56: " compiled dynamically against them. Since only one can be loaded at a time on
line 57: " some platforms, we first check if Python 3 is available.
line 58: elseif !has( 'python3' )
line 59:   echohl WarningMsg | echomsg "YouCompleteMe unavailable: unable to load Python." | echohl None
line 59:  echomsg "YouCompleteMe unavailable: unable to load Python." | echohl None
line 59:  echohl None
line 62:   call s:restore_cpo()
line 63:   finish
line 64: elseif &encoding !~? 'utf-\?8'
line 65:   echohl WarningMsg | echomsg "YouCompleteMe unavailable: requires UTF-8 encoding. " . "Put the line 'set encoding=utf-8' in your vimrc." | echohl None
line 65:  echomsg "YouCompleteMe unavailable: requires UTF-8 encoding. " . "Put the line 'set encoding=utf-8' in your vimrc." | echohl None
line 65:  echohl None
line 69:   call s:restore_cpo()
line 70:   finish
line 71: endif
line 72: 
line 73: let g:loaded_youcompleteme = 1
line 74: 
line 75: "
line 76: " List of YCM options.
line 77: "
line 78: let g:ycm_filetype_whitelist = get( g:, 'ycm_filetype_whitelist', { "*": 1 } )
line 80: 
line 81: let g:ycm_filetype_blacklist = get( g:, 'ycm_filetype_blacklist', {   'tagbar': 1,   'notes': 1,   'markdown': 1,   'netrw': 1,   'unite': 1,   'text': 1,   'vimwiki': 1,   'pandoc': 1,   'infolog': 1,   'leaderf': 1,   'mail': 1 } )
line 95: 
line 96: " Blacklist empty buffers unless explicity whitelisted; workaround for
line 97: " https://github.com/ycm-core/YouCompleteMe/issues/3781
line 98: if !has_key( g:ycm_filetype_whitelist, 'ycm_nofiletype' )
line 99:   let g:ycm_filetype_blacklist.ycm_nofiletype = 1
line 100: endif
line 101: 
line 102: let g:ycm_open_loclist_on_ycm_diags = get( g:, 'ycm_open_loclist_on_ycm_diags', 1 )
line 104: 
line 105: let g:ycm_add_preview_to_completeopt = get( g:, 'ycm_add_preview_to_completeopt', 0 )
line 107: 
line 108: let g:ycm_autoclose_preview_window_after_completion = get( g:, 'ycm_autoclose_preview_window_after_completion', 0 )
line 110: 
line 111: let g:ycm_autoclose_preview_window_after_insertion = get( g:, 'ycm_autoclose_preview_window_after_insertion', 0 )
line 113: 
line 114: let g:ycm_key_list_select_completion = get( g:, 'ycm_key_list_select_completion', ['<TAB>', '<Down>'] )
line 116: 
line 117: let g:ycm_key_list_previous_completion = get( g:, 'ycm_key_list_previous_completion', ['<S-TAB>', '<Up>'] )
line 119: 
line 120: let g:ycm_key_list_stop_completion = get( g:, 'ycm_key_list_stop_completion', ['<C-y>'] )
line 122: 
line 123: let g:ycm_key_invoke_completion = get( g:, 'ycm_key_invoke_completion', '<C-Space>' )
line 125: 
line 126: let g:ycm_key_detailed_diagnostics = get( g:, 'ycm_key_detailed_diagnostics', '<leader>d' )
line 128: 
line 129: let g:ycm_cache_omnifunc = get( g:, 'ycm_cache_omnifunc', 1 )
line 131: 
line 132: let g:ycm_log_level = get( g:, 'ycm_log_level', get( g:, 'ycm_server_log_level', 'info' ) )
line 135: 
line 136: let g:ycm_keep_logfiles = get( g:, 'ycm_keep_logfiles', get( g:, 'ycm_server_keep_logfiles', 0 ) )
line 139: 
line 140: let g:ycm_extra_conf_vim_data = get( g:, 'ycm_extra_conf_vim_data', [] )
line 142: 
line 143: let g:ycm_server_python_interpreter = get( g:, 'ycm_server_python_interpreter', get( g:, 'ycm_path_to_python_interpreter', '' ) )
line 146: 
line 147: let g:ycm_show_diagnostics_ui = get( g:, 'ycm_show_diagnostics_ui', 1 )
line 149: 
line 150: let g:ycm_enable_diagnostic_signs = get( g:, 'ycm_enable_diagnostic_signs', get( g:, 'syntastic_enable_signs', 1 ) )
line 153: 
line 154: let g:ycm_enable_diagnostic_highlighting = get( g:, 'ycm_enable_diagnostic_highlighting', get( g:, 'syntastic_enable_highlighting', 1 ) )
line 157: 
line 158: let g:ycm_echo_current_diagnostic = get( g:, 'ycm_echo_current_diagnostic', get( g:, 'syntastic_echo_current_error', 1 ) )
line 161: 
line 162: let g:ycm_filter_diagnostics = get( g:, 'ycm_filter_diagnostics', {} )
line 164: 
line 165: let g:ycm_always_populate_location_list = get( g:, 'ycm_always_populate_location_list', get( g:, 'syntastic_always_populate_loc_list', 0 ) )
line 168: 
line 169: let g:ycm_error_symbol = get( g:, 'ycm_error_symbol', get( g:, 'syntastic_error_symbol', '>>' ) )
line 172: 
line 173: let g:ycm_warning_symbol = get( g:, 'ycm_warning_symbol', get( g:, 'syntastic_warning_symbol', '>>' ) )
line 176: 
line 177: let g:ycm_complete_in_comments = get( g:, 'ycm_complete_in_comments', 0 )
line 179: 
line 180: let g:ycm_complete_in_strings = get( g:, 'ycm_complete_in_strings', 1 )
line 182: 
line 183: let g:ycm_collect_identifiers_from_tags_files = get( g:, 'ycm_collect_identifiers_from_tags_files', 0 )
line 185: 
line 186: let g:ycm_seed_identifiers_with_syntax = get( g:, 'ycm_seed_identifiers_with_syntax', 0 )
line 188: 
line 189: let g:ycm_goto_buffer_command = get( g:, 'ycm_goto_buffer_command', 'same-buffer' )
line 191: 
line 192: let g:ycm_disable_for_files_larger_than_kb = get( g:, 'ycm_disable_for_files_larger_than_kb', 1000 )
line 194: 
line 195: let g:ycm_auto_hover = get( g:, 'ycm_auto_hover', 'CursorHold' )
line 197: 
line 198: let g:ycm_update_diagnostics_in_insert_mode = get( g:, 'ycm_update_diagnostics_in_insert_mode', 1 )
line 200: 
line 201: "
line 202: " List of ycmd options.
line 203: "
line 204: let g:ycm_filepath_completion_use_working_dir = get( g:, 'ycm_filepath_completion_use_working_dir', 0 )
line 206: 
line 207: let g:ycm_auto_trigger = get( g:, 'ycm_auto_trigger', 1 )
line 209: 
line 210: let g:ycm_min_num_of_chars_for_completion = get( g:, 'ycm_min_num_of_chars_for_completion', 2 )
line 212: 
line 213: let g:ycm_min_identifier_candidate_chars = get( g:, 'ycm_min_num_identifier_candidate_chars', 0 )
line 215: 
line 216: let g:ycm_semantic_triggers = get( g:, 'ycm_semantic_triggers', {} )
line 218: 
line 219: let g:ycm_filetype_specific_completion_to_disable = get( g:, 'ycm_filetype_specific_completion_to_disable',      { 'gitcommit': 1 } )
line 222: 
line 223: let g:ycm_collect_identifiers_from_comments_and_strings = get( g:, 'ycm_collect_identifiers_from_comments_and_strings', 0 )
line 225: 
line 226: let g:ycm_max_num_identifier_candidates = get( g:, 'ycm_max_num_identifier_candidates', 10 )
line 228: 
line 229: let g:ycm_max_num_candidates = get( g:, 'ycm_max_num_candidates', 50 )
line 231: 
line 232: let g:ycm_extra_conf_globlist = get( g:, 'ycm_extra_conf_globlist', [] )
line 234: 
line 235: let g:ycm_global_ycm_extra_conf = get( g:, 'ycm_global_ycm_extra_conf', '' )
line 237: 
line 238: let g:ycm_confirm_extra_conf = get( g:, 'ycm_confirm_extra_conf', 1 )
line 240: 
line 241: let g:ycm_max_diagnostics_to_display = get( g:, 'ycm_max_diagnostics_to_display', 30 )
line 243: 
line 244: let g:ycm_filepath_blacklist = get( g:, 'ycm_filepath_blacklist', {   'html': 1,   'jsx': 1,   'xml': 1 } )
line 250: 
line 251: let g:ycm_auto_start_csharp_server = get( g:, 'ycm_auto_start_csharp_server', 1 )
line 253: 
line 254: let g:ycm_auto_stop_csharp_server = get( g:, 'ycm_auto_stop_csharp_server', 1 )
line 256: 
line 257: let g:ycm_use_ultisnips_completer = get( g:, 'ycm_use_ultisnips_completer', 1 )
line 259: 
line 260: let g:ycm_csharp_server_port = get( g:, 'ycm_csharp_server_port', 0 )
line 262: 
line 263: let g:ycm_use_clangd = get( g:, 'ycm_use_clangd', 1 )
line 265: 
line 266: let g:ycm_clangd_binary_path = get( g:, 'ycm_clangd_binary_path', '' )
line 268: 
line 269: let g:ycm_clangd_args = get( g:, 'ycm_clangd_args', [] )
line 271: 
line 272: let g:ycm_clangd_uses_ycmd_caching = get( g:, 'ycm_clangd_uses_ycmd_caching', 1 )
line 274: 
line 275: " These options are not documented.
line 276: let g:ycm_java_jdtls_extension_path = get( g:, 'ycm_java_jdtls_extension_path', [] )
line 278: 
line 279: let g:ycm_java_jdtls_use_clean_workspace = get( g:, 'ycm_java_jdtls_use_clean_workspace', 1 )
line 281: 
line 282: let g:ycm_java_jdtls_workspace_root_path = get( g:, 'ycm_java_jdtls_workspace_root_path', '' )
line 284: 
line 285: " This option is deprecated.
line 286: let g:ycm_python_binary_path = get( g:, 'ycm_python_binary_path', '' )
line 288: 
line 289: let g:ycm_refilter_workspace_symbols = get( g:, 'ycm_refilter_workspace_symbols', 1 )
line 291: 
line 292: if has( 'vim_starting' ) " Loading at startup.
line 293:   " We defer loading until after VimEnter to allow the gui to fork (see
line 294:   " `:h gui-fork`) and avoid a deadlock situation, as explained here:
line 295:   " https://github.com/Valloric/YouCompleteMe/pull/2473#issuecomment-267716136
line 296:   augroup youcompletemeStart
line 297:     autocmd!
line 298:     autocmd VimEnter * call youcompleteme#Enable()
line 299:   augroup END
line 300: else " Manual loading with :packadd.
line 301:   call youcompleteme#Enable()
line 302: endif
line 303: 
line 304: " This is basic vim plugin boilerplate
line 305: call s:restore_cpo()
calling <SNR>18_restore_cpo()

line 1:   let &cpo = s:save_cpo
line 2:   unlet s:save_cpo
<SNR>18_restore_cpo returning #0

continuing in /home/burp/.vim/bundle/YouCompleteMe/plugin/youcompleteme.vim

finished sourcing /home/burp/.vim/bundle/YouCompleteMe/plugin/youcompleteme.vim
Searching for "/home/burp/.vim/bundle/vim-fugitive/plugin/**/*.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/.vim/bundle/vim-fugitive/plugin)
chdir(/home/burp/Applications/.bash_aliases)
sourcing "/home/burp/.vim/bundle/vim-fugitive/plugin/fugitive.vim"
line 1: " fugitive.vim - A Git wrapper so awesome, it should be illegal
line 2: " Maintainer:   Tim Pope <http://tpo.pe/>
line 3: " Version:      3.7
line 4: " GetLatestVimScripts: 2975 1 :AutoInstall: fugitive.vim
line 5: 
line 6: if exists('g:loaded_fugitive')
line 7:   finish
line 8: endif
line 9: let g:loaded_fugitive = 1
line 10: 
line 11: let s:bad_git_dir = '/$\|^fugitive:'
line 12: 
line 13: " FugitiveGitDir() returns the detected Git dir for the given buffer number,
line 14: " or the current buffer if no argument is passed.  This will be an empty
line 15: " string if no Git dir was found.  Use !empty(FugitiveGitDir()) to check if
line 16: " Fugitive is active in the current buffer.  Do not rely on this for direct
line 17: " filesystem access; use FugitiveFind('.git/whatever') instead.
line 18: function! FugitiveGitDir(...) abort
line 47: 
line 48: " FugitiveReal() takes a fugitive:// URL and returns the corresponding path in
line 49: " the work tree.  This may be useful to get a cleaner path for inclusion in
line 50: " the statusline, for example.  Note that the file and its parent directories
line 51: " are not guaranteed to exist.
line 52: "
line 53: " This is intended as an abstract API to be used on any "virtual" path.  For a
line 54: " buffer named foo://bar, check for a function named FooReal(), and if it
line 55: " exists, call FooReal("foo://bar").
line 56: function! FugitiveReal(...) abort
line 70: 
line 71: " FugitiveFind() takes a Fugitive object and returns the appropriate Vim
line 72: " buffer name.  You can use this to generate Fugitive URLs ("HEAD:README") or
line 73: " to get the absolute path to a file in the Git dir (".git/HEAD"), the common
line 74: " dir (".git/config"), or the work tree (":(top)Makefile").
line 75: "
line 76: " An optional second argument provides the Git dir, or the buffer number of a
line 77: " buffer with a Git dir.  The default is the current buffer.
line 78: function! FugitiveFind(...) abort
line 85: 
line 86: " FugitiveParse() takes a fugitive:// URL and returns a 2 element list
line 87: " containing an object name ("commit:file") and the Git dir.  It's effectively
line 88: " the inverse of FugitiveFind().
line 89: function! FugitiveParse(...) abort
line 100: 
line 101: " FugitiveGitVersion() queries the version of Git in use.  Pass up to 3
line 102: " arguments to return a Boolean of whether a certain minimum version is
line 103: " available (FugitiveGitVersion(2,3,4) checks for 2.3.4 or higher) or no
line 104: " arguments to get a raw string.
line 105: function! FugitiveGitVersion(...) abort
line 108: 
line 109: " FugitiveResult() returns an object encapsulating the result of the most
line 110: " recent :Git command.  Will be empty if no result is available.  During a
line 111: " User FugitiveChanged event, this is guaranteed to correspond to the :Git
line 112: " command that triggered the event, or be empty if :Git was not the trigger.
line 113: " Pass in the name of a temp buffer to get the result object for that command
line 114: " instead.  Contains the following keys:
line 115: "
line 116: " * "args": List of command arguments, starting with the subcommand.  Will be
line 117: "   empty for usages like :Git --help.
line 118: " * "git_dir": Git dir of the relevant repository.
line 119: " * "exit_status": The integer exit code of the process.
line 120: " * "flags": Flags passed directly to Git, like -c and --help.
line 121: " * "file": Path to file containing command output.  Not guaranteed to exist,
line 122: "   so verify with filereadable() before trying to access it.
line 123: function! FugitiveResult(...) abort
line 126: 
line 127: " FugitiveExecute() runs Git with a list of arguments and returns a dictionary
line 128: " with the following keys:
line 129: "
line 130: " * "exit_status": The integer exit code of the process.
line 131: " * "stdout": The stdout produced by the process, as a list of lines.
line 132: " * "stderr": The stdout produced by the process, as a list of lines.
line 133: "
line 134: " An optional second argument provides the Git dir, or the buffer number of a
line 135: " buffer with a Git dir.  The default is the current buffer.
line 136: "
line 137: " An optional final argument is a callback Funcref, for asynchronous
line 138: " execution.
line 139: function! FugitiveExecute(args, ...) abort
line 142: 
line 143: " FugitiveShellCommand() turns an array of arugments into a Git command string
line 144: " which can be executed with functions like system() and commands like :!.
line 145: " Integer arguments will be treated as buffer numbers, and the appropriate
line 146: " relative path inserted in their place.
line 147: "
line 148: " An optional second argument provides the Git dir, or the buffer number of a
line 149: " buffer with a Git dir.  The default is the current buffer.
line 150: function! FugitiveShellCommand(...) abort
line 153: 
line 154: " FugitiveConfig() get returns an opaque structure that can be passed to other
line 155: " FugitiveConfig functions in lieu of a Git directory.  This can be faster
line 156: " when performing multiple config queries.  Do not rely on the internal
line 157: " structure of the return value as it is not guaranteed.  If you want a full
line 158: " dictionary of every config value, use FugitiveConfigGetRegexp('.*').
line 159: "
line 160: " An optional argument provides the Git dir, or the buffer number of a
line 161: " buffer with a Git dir.  The default is the current buffer.  Pass a blank
line 162: " string to limit to the global config.
line 163: function! FugitiveConfig(...) abort
line 166: 
line 167: " FugitiveConfigGet() retrieves a Git configuration value.  An optional second
line 168: " argument can be either the object returned by FugitiveConfig(), or a Git
line 169: " dir or buffer number to be passed along to FugitiveConfig().
line 170: function! FugitiveConfigGet(name, ...) abort
line 173: 
line 174: " FugitiveConfigGetAll() is like FugitiveConfigGet() but returns a list of
line 175: " all values.
line 176: function! FugitiveConfigGetAll(name, ...) abort
line 179: 
line 180: " FugitiveConfigGetRegexp() retrieves a dictionary of all configuration values
line 181: " with a key matching the given pattern.  Like git config --get-regexp, but
line 182: " using a Vim regexp.  Second argument has same semantics as
line 183: " FugitiveConfigGet().
line 184: function! FugitiveConfigGetRegexp(pattern, ...) abort
line 187: 
line 188: " FugitiveRemoteUrl() retrieves the remote URL for the given remote name,
line 189: " defaulting to the current branch's remote or "origin" if no argument is
line 190: " given.  Similar to `git remote get-url`, but also attempts to resolve HTTP
line 191: " redirects and SSH host aliases.
line 192: "
line 193: " An optional second argument provides the Git dir, or the buffer number of a
line 194: " buffer with a Git dir.  The default is the current buffer.
line 195: function! FugitiveRemoteUrl(...) abort
line 198: 
line 199: " FugitiveRemote() returns a data structure parsed from the remote URL.
line 200: " For example, for remote URL "https://me@example.com:1234/repo.git", the
line 201: " returned dictionary will contain the following:
line 202: "
line 203: " * "scheme": "https"
line 204: " * "authority": "user@example.com:1234"
line 205: " * "path": "/repo.git" (for SSH URLs this may be a relative path)
line 206: " * "pathname": "/repo.git" (always coerced to absolute path)
line 207: " * "host": "example.com:1234"
line 208: " * "hostname": "example.com"
line 209: " * "port": "1234"
line 210: " * "user": "me"
line 211: " * "path": "/repo.git"
line 212: " * "url": "https://me@example.com:1234/repo.git"
line 213: function! FugitiveRemote(...) abort
line 216: 
line 217: " FugitiveDidChange() triggers a FugitiveChanged event and reloads the summary
line 218: " buffer for the current or given buffer number's repository.  You can also
line 219: " give the result of a FugitiveExecute() and that context will be made
line 220: " available inside the FugitiveChanged() event.
line 221: "
line 222: " Passing the special argument 0 (the number zero) softly expires summary
line 223: " buffers for all repositories.  This can be used after a call to system()
line 224: " with unclear implications.
line 225: function! FugitiveDidChange(...) abort
line 228: 
line 229: " FugitiveHead() retrieves the name of the current branch. If the current HEAD
line 230: " is detached, FugitiveHead() will return the empty string, unless the
line 231: " optional argument is given, in which case the hash of the current commit
line 232: " will be truncated to the given number of characters.
line 233: "
line 234: " An optional second argument provides the Git dir, or the buffer number of a
line 235: " buffer with a Git dir.  The default is the current buffer.
line 236: function! FugitiveHead(...) abort
line 252: 
line 253: function! FugitivePath(...) abort
line 264: 
line 265: function! FugitiveStatusline(...) abort
line 271: 
line 272: let s:resolved_git_dirs = {}
line 273: function! FugitiveActualDir(...) abort
line 283: 
line 284: let s:commondirs = {}
line 285: function! FugitiveCommonDir(...) abort
line 307: 
line 308: function! FugitiveWorkTree(...) abort
line 316: 
line 317: function! FugitiveIsGitDir(...) abort
line 326: 
line 327: function! s:ReadFile(path, line_count) abort
line 337: 
line 338: let s:worktree_for_dir = {}
line 339: let s:dir_for_worktree = {}
line 340: function! s:Tree(path) abort
line 387: 
line 388: function! s:CeilingDirectories() abort
line 404: 
line 405: function! s:ResolveGitDir(git_dir) abort
line 422: 
line 423: function! FugitiveExtractGitDir(path) abort
line 468: 
line 469: function! FugitiveDetect(...) abort
line 481: 
line 482: function! FugitiveGitPath(path) abort
line 485: 
line 486: if exists('+shellslash')
line 487: 
line 488:   function! s:Slash(path) abort
line 491: 
line 492:   function! s:VimSlash(path) abort
line 495: 
line 496:   function FugitiveVimPath(path) abort
line 499: 
line 500: else
line 501: 
line 502:   function! s:Slash(path) abort
line 505: 
line 506:   function! s:VimSlash(path) abort
line 509: 
line 510:   if has('win32unix') && filereadable('/git-bash.exe')
line 511:     function! FugitiveVimPath(path) abort
line 514:   else
line 515:     function! FugitiveVimPath(path) abort
line 518:   endif
line 519: 
line 520: endif
line 521: 
line 522: function! s:ProjectionistDetect() abort
line 539: 
line 540: let s:addr_other = has('patch-8.1.560') || has('nvim-0.5.0') ? '-addr=other' : ''
line 541: let s:addr_tabs  = has('patch-7.4.542') ? '-addr=tabs' : ''
line 542: let s:addr_wins  = has('patch-7.4.542') ? '-addr=windows' : ''
line 543: 
line 544: if exists(':G') != 2
line 545:   command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#Complete G   exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 546: endif
line 547: command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#Complete Git exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 548: 
line 549: if exists(':Gstatus') != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 550:   exe 'command! -bang -bar     -range=-1' s:addr_other 'Gstatus exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)' '|echohl WarningMSG|echomsg ":Gstatus is deprecated in favor of :Git (with no arguments)"|echohl NONE'
line 552: endif
line 553: 
line 554: for s:cmd in ['Commit', 'Revert', 'Merge', 'Rebase', 'Pull', 'Push', 'Fetch', 'Blame']
line 555:   if exists(':G' . tolower(s:cmd)) != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 556:     exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd) 'echohl WarningMSG|echomsg ":G' . tolower(s:cmd) . ' is deprecated in favor of :Git ' . tolower(s:cmd) . '"|echohl NONE|' 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
line 559:   endif
line 560: endfor
line 554: for s:cmd in ['Commit', 'Revert', 'Merge', 'Rebase', 'Pull', 'Push', 'Fetch', 'Blame']
line 555:   if exists(':G' . tolower(s:cmd)) != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 556:     exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd) 'echohl WarningMSG|echomsg ":G' . tolower(s:cmd) . ' is deprecated in favor of :Git ' . tolower(s:cmd) . '"|echohl NONE|' 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
line 559:   endif
line 560: endfor
line 554: for s:cmd in ['Commit', 'Revert', 'Merge', 'Rebase', 'Pull', 'Push', 'Fetch', 'Blame']
line 555:   if exists(':G' . tolower(s:cmd)) != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 556:     exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd) 'echohl WarningMSG|echomsg ":G' . tolower(s:cmd) . ' is deprecated in favor of :Git ' . tolower(s:cmd) . '"|echohl NONE|' 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
line 559:   endif
line 560: endfor
line 554: for s:cmd in ['Commit', 'Revert', 'Merge', 'Rebase', 'Pull', 'Push', 'Fetch', 'Blame']
line 555:   if exists(':G' . tolower(s:cmd)) != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 556:     exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd) 'echohl WarningMSG|echomsg ":G' . tolower(s:cmd) . ' is deprecated in favor of :Git ' . tolower(s:cmd) . '"|echohl NONE|' 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
line 559:   endif
line 560: endfor
line 554: for s:cmd in ['Commit', 'Revert', 'Merge', 'Rebase', 'Pull', 'Push', 'Fetch', 'Blame']
line 555:   if exists(':G' . tolower(s:cmd)) != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 556:     exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd) 'echohl WarningMSG|echomsg ":G' . tolower(s:cmd) . ' is deprecated in favor of :Git ' . tolower(s:cmd) . '"|echohl NONE|' 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
line 559:   endif
line 560: endfor
line 554: for s:cmd in ['Commit', 'Revert', 'Merge', 'Rebase', 'Pull', 'Push', 'Fetch', 'Blame']
line 555:   if exists(':G' . tolower(s:cmd)) != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 556:     exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd) 'echohl WarningMSG|echomsg ":G' . tolower(s:cmd) . ' is deprecated in favor of :Git ' . tolower(s:cmd) . '"|echohl NONE|' 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
line 559:   endif
line 560: endfor
line 554: for s:cmd in ['Commit', 'Revert', 'Merge', 'Rebase', 'Pull', 'Push', 'Fetch', 'Blame']
line 555:   if exists(':G' . tolower(s:cmd)) != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 556:     exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd) 'echohl WarningMSG|echomsg ":G' . tolower(s:cmd) . ' is deprecated in favor of :Git ' . tolower(s:cmd) . '"|echohl NONE|' 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
line 559:   endif
line 560: endfor
line 554: for s:cmd in ['Commit', 'Revert', 'Merge', 'Rebase', 'Pull', 'Push', 'Fetch', 'Blame']
line 555:   if exists(':G' . tolower(s:cmd)) != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 556:     exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd) 'echohl WarningMSG|echomsg ":G' . tolower(s:cmd) . ' is deprecated in favor of :Git ' . tolower(s:cmd) . '"|echohl NONE|' 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
line 559:   endif
line 560: endfor
line 554: for s:cmd in ['Commit', 'Revert', 'Merge', 'Rebase', 'Pull', 'Push', 'Fetch', 'Blame']
line 555:   if exists(':G' . tolower(s:cmd)) != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 556:     exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd) 'echohl WarningMSG|echomsg ":G' . tolower(s:cmd) . ' is deprecated in favor of :Git ' . tolower(s:cmd) . '"|echohl NONE|' 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
line 559:   endif
line 560: endfor
line 561: unlet s:cmd
line 562: 
line 563: exe "command! -bar -bang -nargs=? -complete=customlist,fugitive#CdComplete Gcd  exe fugitive#Cd(<q-args>, 0)"
line 563: command! -bar -bang -nargs=? -complete=customlist,fugitive#CdComplete Gcd  exe fugitive#Cd(<q-args>, 0)
line 564: exe "command! -bar -bang -nargs=? -complete=customlist,fugitive#CdComplete Glcd exe fugitive#Cd(<q-args>, 1)"
line 564: command! -bar -bang -nargs=? -complete=customlist,fugitive#CdComplete Glcd exe fugitive#Cd(<q-args>, 1)
line 565: 
line 566: exe 'command! -bang -nargs=? -range=-1' s:addr_wins '-complete=customlist,fugitive#GrepComplete Ggrep  exe fugitive#GrepCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 566: command! -bang -nargs=? -range=-1 -addr=windows -complete=customlist,fugitive#GrepComplete Ggrep  exe fugitive#GrepCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 567: exe 'command! -bang -nargs=? -range=-1' s:addr_wins '-complete=customlist,fugitive#GrepComplete Glgrep exe fugitive#GrepCommand(0, <count> > 0 ? <count> : 0, +"<range>", <bang>0, "<mods>", <q-args>)'
line 567: command! -bang -nargs=? -range=-1 -addr=windows -complete=customlist,fugitive#GrepComplete Glgrep exe fugitive#GrepCommand(0, <count> > 0 ? <count> : 0, +"<range>", <bang>0, "<mods>", <q-args>)
line 568: 
line 569: exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete Gclog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "c")'
line 569: command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete Gclog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "c")
line 570: exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete GcLog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "c")'
line 570: command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete GcLog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "c")
line 571: exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete Gllog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "l")'
line 571: command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete Gllog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "l")
line 572: exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete GlLog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "l")'
line 572: command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete GlLog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "l")
line 573: 
line 574: exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Ge       exe fugitive#Open("edit<bang>", 0, "<mods>", <q-args>)'
line 574: command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Ge       exe fugitive#Open("edit<bang>", 0, "<mods>", <q-args>)
line 575: exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Gedit    exe fugitive#Open("edit<bang>", 0, "<mods>", <q-args>)'
line 575: command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Gedit    exe fugitive#Open("edit<bang>", 0, "<mods>", <q-args>)
line 576: exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Gpedit   exe fugitive#Open("pedit", <bang>0, "<mods>", <q-args>)'
line 576: command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Gpedit   exe fugitive#Open("pedit", <bang>0, "<mods>", <q-args>)
line 577: exe 'command! -bar -bang -nargs=* -range=-1' s:addr_other '-complete=customlist,fugitive#EditComplete   Gsplit   exe fugitive#Open((<count> > 0 ? <count> : "").(<count> ? "split" : "edit"), <bang>0, "<mods>", <q-args>)'
line 577: command! -bar -bang -nargs=* -range=-1 -addr=other -complete=customlist,fugitive#EditComplete   Gsplit   exe fugitive#Open((<count> > 0 ? <count> : "").(<count> ? "split" : "edit"), <bang>0, "<mods>", <q-args>)
line 578: exe 'command! -bar -bang -nargs=* -range=-1' s:addr_other '-complete=customlist,fugitive#EditComplete   Gvsplit  exe fugitive#Open((<count> > 0 ? <count> : "").(<count> ? "vsplit" : "edit!"), <bang>0, "<mods>", <q-args>)'
line 578: command! -bar -bang -nargs=* -range=-1 -addr=other -complete=customlist,fugitive#EditComplete   Gvsplit  exe fugitive#Open((<count> > 0 ? <count> : "").(<count> ? "vsplit" : "edit!"), <bang>0, "<mods>", <q-args>)
line 579: exe 'command! -bar -bang -nargs=* -range=-1' s:addr_tabs  '-complete=customlist,fugitive#EditComplete   Gtabedit exe fugitive#Open((<count> >= 0 ? <count> : "")."tabedit", <bang>0, "<mods>", <q-args>)'
line 579: command! -bar -bang -nargs=* -range=-1 -addr=tabs -complete=customlist,fugitive#EditComplete   Gtabedit exe fugitive#Open((<count> >= 0 ? <count> : "")."tabedit", <bang>0, "<mods>", <q-args>)
line 580: exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Gdrop    exe fugitive#DropCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 580: command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Gdrop    exe fugitive#DropCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 581: 
line 582: if exists(':Gr') != 2
line 583:   exe 'command! -bar -bang -nargs=* -range=-1                -complete=customlist,fugitive#ReadComplete   Gr     exe fugitive#ReadCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 583: command! -bar -bang -nargs=* -range=-1                -complete=customlist,fugitive#ReadComplete   Gr     exe fugitive#ReadCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 584: endif
line 585: exe 'command! -bar -bang -nargs=* -range=-1                -complete=customlist,fugitive#ReadComplete   Gread    exe fugitive#ReadCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 585: command! -bar -bang -nargs=* -range=-1                -complete=customlist,fugitive#ReadComplete   Gread    exe fugitive#ReadCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 586: 
line 587: exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gdiffsplit  exe fugitive#Diffsplit(1, <bang>0, "<mods>", <q-args>)'
line 587: command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gdiffsplit  exe fugitive#Diffsplit(1, <bang>0, "<mods>", <q-args>)
line 588: exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Ghdiffsplit exe fugitive#Diffsplit(0, <bang>0, "<mods>", <q-args>)'
line 588: command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Ghdiffsplit exe fugitive#Diffsplit(0, <bang>0, "<mods>", <q-args>)
line 589: exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gvdiffsplit exe fugitive#Diffsplit(0, <bang>0, "vertical <mods>", <q-args>)'
line 589: command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gvdiffsplit exe fugitive#Diffsplit(0, <bang>0, "vertical <mods>", <q-args>)
line 590: 
line 591: exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gw     exe fugitive#WriteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 591: command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gw     exe fugitive#WriteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 592: exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gwrite exe fugitive#WriteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 592: command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gwrite exe fugitive#WriteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 593: exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gwq    exe fugitive#WqCommand(   <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 593: command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gwq    exe fugitive#WqCommand(   <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 594: 
line 595: exe 'command! -bar -bang -nargs=0 GRemove exe fugitive#RemoveCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 595: command! -bar -bang -nargs=0 GRemove exe fugitive#RemoveCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 596: exe 'command! -bar -bang -nargs=0 GUnlink exe fugitive#UnlinkCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 596: command! -bar -bang -nargs=0 GUnlink exe fugitive#UnlinkCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 597: exe 'command! -bar -bang -nargs=0 GDelete exe fugitive#DeleteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 597: command! -bar -bang -nargs=0 GDelete exe fugitive#DeleteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 598: exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#CompleteObject GMove   exe fugitive#MoveCommand(  <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 598: command! -bar -bang -nargs=1 -complete=customlist,fugitive#CompleteObject GMove   exe fugitive#MoveCommand(  <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 599: exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#RenameComplete GRename exe fugitive#RenameCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 599: command! -bar -bang -nargs=1 -complete=customlist,fugitive#RenameComplete GRename exe fugitive#RenameCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 600: if exists(':Gremove') != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 601:   exe 'command! -bar -bang -nargs=0 Gremove exe fugitive#RemoveCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)' '|echohl WarningMSG|echomsg ":Gremove is deprecated in favor of :GRemove"|echohl NONE'
line 603: elseif exists(':Gremove') != 2 && !exists('g:fugitive_legacy_commands')
line 604:   exe 'command! -bar -bang -nargs=0 Gremove echoerr ":Gremove has been removed in favor of :GRemove"'
line 604: command! -bar -bang -nargs=0 Gremove echoerr ":Gremove has been removed in favor of :GRemove"
line 605: endif
line 606: if exists(':Gdelete') != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 607:   exe 'command! -bar -bang -nargs=0 Gdelete exe fugitive#DeleteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)' '|echohl WarningMSG|echomsg ":Gdelete is deprecated in favor of :GDelete"|echohl NONE'
line 609: elseif exists(':Gdelete') != 2 && !exists('g:fugitive_legacy_commands')
line 610:   exe 'command! -bar -bang -nargs=0 Gdelete echoerr ":Gremove has been removed in favor of :GRemove"'
line 610: command! -bar -bang -nargs=0 Gdelete echoerr ":Gremove has been removed in favor of :GRemove"
line 611: endif
line 612: if exists(':Gmove') != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 613:   exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#CompleteObject Gmove   exe fugitive#MoveCommand(  <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)' '|echohl WarningMSG|echomsg ":Gmove is deprecated in favor of :GMove"|echohl NONE'
line 615: elseif exists(':Gmove') != 2 && !exists('g:fugitive_legacy_commands')
line 616:   exe 'command! -bar -bang -nargs=? -complete=customlist,fugitive#CompleteObject Gmove' 'echoerr ":Gmove has been removed in favor of :GMove"'
line 616: command! -bar -bang -nargs=? -complete=customlist,fugitive#CompleteObject Gmove echoerr ":Gmove has been removed in favor of :GMove"
line 618: endif
line 619: if exists(':Grename') != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 620:   exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#RenameComplete Grename exe fugitive#RenameCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)' '|echohl WarningMSG|echomsg ":Grename is deprecated in favor of :GRename"|echohl NONE'
line 622: elseif exists(':Grename') != 2 && !exists('g:fugitive_legacy_commands')
line 623:   exe 'command! -bar -bang -nargs=? -complete=customlist,fugitive#RenameComplete Grename' 'echoerr ":Grename has been removed in favor of :GRename"'
line 623: command! -bar -bang -nargs=? -complete=customlist,fugitive#RenameComplete Grename echoerr ":Grename has been removed in favor of :GRename"
line 625: endif
line 626: 
line 627: exe 'command! -bar -bang -range=-1 -nargs=* -complete=customlist,fugitive#CompleteObject GBrowse exe fugitive#BrowseCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 627: command! -bar -bang -range=-1 -nargs=* -complete=customlist,fugitive#CompleteObject GBrowse exe fugitive#BrowseCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 628: if exists(':Gbrowse') != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 629:   exe 'command! -bar -bang -range=-1 -nargs=* -complete=customlist,fugitive#CompleteObject Gbrowse exe fugitive#BrowseCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)' '|if <bang>1|redraw!|endif|echohl WarningMSG|echomsg ":Gbrowse is deprecated in favor of :GBrowse"|echohl NONE'
line 631: elseif exists(':Gbrowse') != 2 && !exists('g:fugitive_legacy_commands')
line 632:   exe 'command! -bar -bang -range=-1 -nargs=* -complete=customlist,fugitive#CompleteObject Gbrowse' 'echoerr ":Gbrowse has been removed in favor of :GBrowse"'
line 632: command! -bar -bang -range=-1 -nargs=* -complete=customlist,fugitive#CompleteObject Gbrowse echoerr ":Gbrowse has been removed in favor of :GBrowse"
line 634: endif
line 635: 
line 636: if v:version < 704
line 637:   finish
line 638: endif
line 639: 
line 640: let g:io_fugitive = { 'simplify': function('fugitive#simplify'), 'resolve': function('fugitive#resolve'), 'getftime': function('fugitive#getftime'), 'getfsize': function('fugitive#getfsize'), 'getftype': function('fugitive#getftype'), 'filereadable': function('fugitive#filereadable'), 'filewritable': function('fugitive#filewritable'), 'isdirectory': function('fugitive#isdirectory'), 'getfperm': function('fugitive#getfperm'), 'setfperm': function('fugitive#setfperm'), 'readfile': function('fugitive#readfile'), 'writefile': function('fugitive#writefile'), 'glob': function('fugitive#glob'), 'delete': function('fugitive#delete'), 'Real': function('FugitiveReal')}
line 656: 
line 657: augroup fugitive
line 658:   autocmd!
line 659: 
line 660:   autocmd BufNewFile,BufReadPost * if exists('b:git_dir') && b:git_dir =~# '^$\|' . s:bad_git_dir |   unlet b:git_dir | endif
line 664:   autocmd FileType           netrw if exists('b:git_dir') && b:git_dir =~# '^$\|' . s:bad_git_dir |   unlet b:git_dir | endif
line 668:   autocmd BufFilePost            *  unlet! b:git_dir
line 669: 
line 670:   autocmd FileType git call fugitive#MapCfile()
line 672:   autocmd FileType gitcommit call fugitive#MapCfile('fugitive#MessageCfile()')
line 674:   autocmd FileType git,gitcommit if &foldtext ==# 'foldtext()' |    setlocal foldtext=fugitive#Foldtext() | endif
line 678:   autocmd FileType fugitive call fugitive#MapCfile('fugitive#PorcelainCfile()')
line 680:   autocmd FileType gitrebase let &l:include = '^\%(pick\|squash\|edit\|reword\|fixup\|drop\|[pserfd]\)\>' | if &l:includeexpr !~# 'Fugitive' |   let &l:includeexpr = 'v:fname =~# ''^\x\{4,\}$'' && len(FugitiveGitDir()) ? FugitiveFind(v:fname) : ' .     (len(&l:includeexpr) ? &l:includeexpr : 'v:fname') | endif | let b:undo_ftplugin = get(b:, 'undo_ftplugin', 'exe') . '|setl inex= inc='
line 687: 
line 688:   autocmd BufReadCmd index{,.lock} nested if FugitiveIsGitDir(expand('<amatch>:p:h')) |   let b:git_dir = s:Slash(expand('<amatch>:p:h')) |   exe fugitive#BufReadStatus(v:cmdbang) | elseif filereadable(expand('<amatch>')) |   silent doautocmd BufReadPre |   keepalt noautocmd read <amatch> |   silent 1delete_ |   silent doautocmd BufReadPost | else |   silent doautocmd BufNewFile | endif
line 700: 
line 701:   autocmd BufReadCmd   fugitive://*          nested exe fugitive#BufReadCmd() | if &path =~# '^\.\%(,\|$\)' |   let &l:path = substitute(&path, '^\.,\=', '', '') | endif
line 705:   autocmd BufWriteCmd  fugitive://*          nested exe fugitive#BufWriteCmd()
line 706:   autocmd FileReadCmd  fugitive://*          nested exe fugitive#FileReadCmd()
line 707:   autocmd FileWriteCmd fugitive://*          nested exe fugitive#FileWriteCmd()
line 708:   if exists('##SourceCmd')
line 709:     autocmd SourceCmd     fugitive://*       nested exe fugitive#SourceCmd()
line 710:   endif
line 711: 
line 712:   autocmd User Flags call Hoist('buffer', function('FugitiveStatusline'))
line 713: 
line 714:   autocmd User ProjectionistDetect call s:ProjectionistDetect()
line 715: augroup END
line 716: 
line 717: nmap <script><silent> <Plug>fugitive:y<C-G> :<C-U>call setreg(v:register, fugitive#Object(@%))<CR>
line 718: nmap <script> <Plug>fugitive: <Nop>
line 719: 
line 720: if get(g:, 'fugitive_no_maps')
line 721:   finish
line 722: endif
line 723: 
line 724: function! s:Map(mode, lhs, rhs, flags) abort
line 746: 
line 747: call s:Map('c', '<C-R><C-G>', 'fnameescape(fugitive#Object(@%))', '<expr>')
calling <SNR>22_Map('c', '<C-R><C-G>', 'fnameescape(fugitive#Object(@%))', '<expr>')

line 1:   let flags = a:flags . (a:rhs =~# '<Plug>' ? '' : '<script>') . '<nowait>'
line 2:   let head = a:lhs
line 3:   let tail = ''
line 4:   let keys = get(g:, a:mode.'remap', {})
line 5:   if len(keys) && type(keys) == type({})
line 6:     while !empty(head)
line 7:       if has_key(keys, head)
line 8:         let head = keys[head]
line 9:         if empty(head)
line 10:           return
line 11:         endif
line 12:         break
line 13:       endif
line 14:       let tail = matchstr(head, '<[^<>]*>$\|.$') . tail
line 15:       let head = substitute(head, '<[^<>]*>$\|.$', '', '')
line 16:     endwhile
line 17:   endif
line 18:   if empty(mapcheck(head.tail, a:mode))
line 19:     exe a:mode.'map' flags head.tail a:rhs
line 19: cmap <expr><script><nowait> <C-R><C-G> fnameescape(fugitive#Object(@%))
line 20:   endif
<SNR>22_Map returning #0

continuing in /home/burp/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 748: call s:Map('n', 'y<C-G>', ':<C-U>call setreg(v:register, fugitive#Object(@%))<CR>', '<silent>')
calling <SNR>22_Map('n', 'y<C-G>', ':<C-U>call setreg(v:register, fugitive#Object(@%))<CR>', '<silent>')

line 1:   let flags = a:flags . (a:rhs =~# '<Plug>' ? '' : '<script>') . '<nowait>'
line 2:   let head = a:lhs
line 3:   let tail = ''
line 4:   let keys = get(g:, a:mode.'remap', {})
line 5:   if len(keys) && type(keys) == type({})
line 6:     while !empty(head)
line 7:       if has_key(keys, head)
line 8:         let head = keys[head]
line 9:         if empty(head)
line 10:           return
line 11:         endif
line 12:         break
line 13:       endif
line 14:       let tail = matchstr(head, '<[^<>]*>$\|.$') . tail
line 15:       let head = substitute(head, '<[^<>]*>$\|.$', '', '')
line 16:     endwhile
line 17:   endif
line 18:   if empty(mapcheck(head.tail, a:mode))
line 19:     exe a:mode.'map' flags head.tail a:rhs
line 19: nmap <silent><script><nowait> y<C-G> :<C-U>call setreg(v:register, fugitive#Object(@%))<CR>
line 20:   endif
<SNR>22_Map returning #0

continuing in /home/burp/.vim/bundle/vim-fugitive/plugin/fugitive.vim

finished sourcing /home/burp/.vim/bundle/vim-fugitive/plugin/fugitive.vim
Searching for "/home/burp/.vim/bundle/vim-tmux-navigator/plugin/**/*.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/.vim/bundle/vim-tmux-navigator/plugin)
chdir(/home/burp/Applications/.bash_aliases)
sourcing "/home/burp/.vim/bundle/vim-tmux-navigator/plugin/tmux_navigator.vim"
line 1: " Maps <C-h/j/k/l> to switch vim splits in the given direction. If there are
line 2: " no more windows in that direction, forwards the operation to tmux.
line 3: " Additionally, <C-\> toggles between last active vim splits/tmux panes.
line 4: 
line 5: if exists("g:loaded_tmux_navigator") || &cp || v:version < 700
line 6:   finish
line 7: endif
line 8: let g:loaded_tmux_navigator = 1
line 9: 
line 10: function! s:VimNavigate(direction)
line 17: 
line 18: if !get(g:, 'tmux_navigator_no_mappings', 0)
line 19:   noremap <silent> <c-h> :<C-U>TmuxNavigateLeft<cr>
line 20:   noremap <silent> <c-j> :<C-U>TmuxNavigateDown<cr>
line 21:   noremap <silent> <c-k> :<C-U>TmuxNavigateUp<cr>
line 22:   noremap <silent> <c-l> :<C-U>TmuxNavigateRight<cr>
line 23:   noremap <silent> <c-\> :<C-U>TmuxNavigatePrevious<cr>
line 24: endif
line 25: 
line 26: if empty($TMUX)
line 27:   command! TmuxNavigateLeft call s:VimNavigate('h')
line 28:   command! TmuxNavigateDown call s:VimNavigate('j')
line 29:   command! TmuxNavigateUp call s:VimNavigate('k')
line 30:   command! TmuxNavigateRight call s:VimNavigate('l')
line 31:   command! TmuxNavigatePrevious call s:VimNavigate('p')
line 32:   finish
line 33: endif
line 34: 
line 35: command! TmuxNavigateLeft call s:TmuxAwareNavigate('h')
line 36: command! TmuxNavigateDown call s:TmuxAwareNavigate('j')
line 37: command! TmuxNavigateUp call s:TmuxAwareNavigate('k')
line 38: command! TmuxNavigateRight call s:TmuxAwareNavigate('l')
line 39: command! TmuxNavigatePrevious call s:TmuxAwareNavigate('p')
line 40: 
line 41: if !exists("g:tmux_navigator_save_on_switch")
line 42:   let g:tmux_navigator_save_on_switch = 0
line 43: endif
line 44: 
line 45: if !exists("g:tmux_navigator_disable_when_zoomed")
line 46:   let g:tmux_navigator_disable_when_zoomed = 0
line 47: endif
line 48: 
line 49: if !exists("g:tmux_navigator_preserve_zoom")
line 50:   let g:tmux_navigator_preserve_zoom = 0
line 51: endif
line 52: 
line 53: if !exists("g:tmux_navigator_no_wrap")
line 54:   let g:tmux_navigator_no_wrap = 0
line 55: endif
line 56: 
line 57: let s:pane_position_from_direction = {'h': 'left', 'j': 'bottom', 'k': 'top', 'l': 'right'}
line 58: 
line 59: function! s:TmuxOrTmateExecutable()
line 62: 
line 63: function! s:TmuxVimPaneIsZoomed()
line 66: 
line 67: function! s:TmuxSocket()
line 71: 
line 72: function! s:TmuxCommand(args)
line 80: 
line 81: function! s:TmuxNavigatorProcessList()
line 84: command! TmuxNavigatorProcessList call s:TmuxNavigatorProcessList()
line 85: 
line 86: let s:tmux_is_last_pane = 0
line 87: augroup tmux_navigator
line 88:   au!
line 89:   autocmd WinEnter * let s:tmux_is_last_pane = 0
line 90: augroup END
line 91: 
line 92: function! s:NeedsVitalityRedraw()
line 95: 
line 96: function! s:ShouldForwardNavigationBackToTmux(tmux_last_pane, at_tab_page_edge)
line 102: 
line 103: function! s:TmuxAwareNavigate(direction)
finished sourcing /home/burp/.vim/bundle/vim-tmux-navigator/plugin/tmux_navigator.vim
Searching for "/etc/xdg/nvim/plugin/**/*.vim"
Searching for "/home/burp/.local/share/nvim/site/plugin/**/*.vim"
Searching for "/usr/local/share/nvim/site/plugin/**/*.vim"
Searching for "/usr/share/nvim/site/plugin/**/*.vim"
Searching for "/usr/share/nvim/runtime/plugin/**/*.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/burp/Applications/.bash_aliases)
sourcing "/usr/share/nvim/runtime/plugin/gzip.vim"
line 1: " Vim plugin for editing compressed files.
line 2: " Maintainer: Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2016 Oct 30
line 4: 
line 5: " Exit quickly when:
line 6: " - this plugin was already loaded
line 7: " - when 'compatible' is set
line 8: " - some autocommands are already taking care of compressed files
line 9: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
line 10:   finish
line 11: endif
line 12: let loaded_gzip = 1
line 13: 
line 14: augroup gzip
line 15:   " Remove all gzip autocommands
line 16:   au!
line 17: 
line 18:   " Enable editing of gzipped files.
line 19:   " The functions are defined in autoload/gzip.vim.
line 20:   "
line 21:   " Set binary mode before reading the file.
line 22:   " Use "gzip -d", gunzip isn't always available.
line 23:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst,*.br,*.lzo setlocal bin
line 24:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")
line 25:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")
line 26:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")
line 27:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")
line 28:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")
line 29:   autocmd BufReadPost,FileReadPost^I*.lz  call gzip#read("lzip -d")
line 30:   autocmd BufReadPost,FileReadPost^I*.zst call gzip#read("zstd -d --rm")
line 31:   autocmd BufReadPost,FileReadPost^I*.br call gzip#read("brotli -d --rm")
line 32:   autocmd BufReadPost,FileReadPost^I*.lzo call gzip#read("lzop -d -U")
line 33:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")
line 34:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")
line 35:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")
line 36:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")
line 37:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")
line 38:   autocmd BufWritePost,FileWritePost^I*.lz  call gzip#write("lzip")
line 39:   autocmd BufWritePost,FileWritePost^I*.zst  call gzip#write("zstd --rm")
line 40:   autocmd BufWritePost,FileWritePost^I*.br  call gzip#write("brotli --rm")
line 41:   autocmd BufWritePost,FileWritePost^I*.lzo  call gzip#write("lzop -U")
line 42:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")
line 43:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")
line 44:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")
line 45:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")
line 46:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")
line 47:   autocmd FileAppendPre^I^I^I*.lz   call gzip#appre("lzip -d")
line 48:   autocmd FileAppendPre^I^I^I*.zst call gzip#appre("zstd -d --rm")
line 49:   autocmd FileAppendPre^I^I^I*.br call gzip#appre("brotli -d --rm")
line 50:   autocmd FileAppendPre^I^I^I*.lzo call gzip#appre("lzop -d -U")
line 51:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")
line 52:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")
line 53:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")
line 54:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")
line 55:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")
line 56:   autocmd FileAppendPost^I^I*.lz call gzip#write("lzip")
line 57:   autocmd FileAppendPost^I^I*.zst call gzip#write("zstd --rm")
line 58:   autocmd FileAppendPost^I^I*.br call gzip#write("brotli --rm")
line 59:   autocmd FileAppendPost^I^I*.lzo call gzip#write("lzop -U")
line 60: augroup END
finished sourcing /usr/share/nvim/runtime/plugin/gzip.vim
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/burp/Applications/.bash_aliases)
sourcing "/usr/share/nvim/runtime/plugin/health.vim"
line 1: autocmd CmdUndefined CheckHealth checkhealth
finished sourcing /usr/share/nvim/runtime/plugin/health.vim
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/burp/Applications/.bash_aliases)
sourcing "/usr/share/nvim/runtime/plugin/matchit.vim"
line 1: " Nvim: load the matchit plugin by default.
line 2: if !exists("g:loaded_matchit") && stridx(&packpath, $VIMRUNTIME) >= 0
line 3:   packadd matchit
Searching for "pack/*/start/matchit" in "/home/burp/.config/nvim,/etc/xdg/nvim,/home/burp/.local/share/nvim/site,/usr/local/share/nvim/site,/usr/share/nvim/site,/usr/share/nvim/runtime,/usr/lib/nvim,/usr/share/nvim/site/after,/usr/local/share/nvim/site/after,/home/burp/.local/share/nvim/site/after,/etc/xdg/nvim/after,/home/burp/.config/nvim/after"
Searching for "/home/burp/.config/nvim/pack/*/start/matchit"
Searching for "/etc/xdg/nvim/pack/*/start/matchit"
Searching for "/home/burp/.local/share/nvim/site/pack/*/start/matchit"
Searching for "/usr/local/share/nvim/site/pack/*/start/matchit"
Searching for "/usr/share/nvim/site/pack/*/start/matchit"
Searching for "/usr/share/nvim/runtime/pack/*/start/matchit"
Searching for "/usr/lib/nvim/pack/*/start/matchit"
Searching for "/usr/share/nvim/site/after/pack/*/start/matchit"
Searching for "/usr/local/share/nvim/site/after/pack/*/start/matchit"
Searching for "/home/burp/.local/share/nvim/site/after/pack/*/start/matchit"
Searching for "/etc/xdg/nvim/after/pack/*/start/matchit"
Searching for "/home/burp/.config/nvim/after/pack/*/start/matchit"
not found in 'packpath': "pack/*/start/matchit"
Searching for "pack/*/opt/matchit" in "/home/burp/.config/nvim,/etc/xdg/nvim,/home/burp/.local/share/nvim/site,/usr/local/share/nvim/site,/usr/share/nvim/site,/usr/share/nvim/runtime,/usr/lib/nvim,/usr/share/nvim/site/after,/usr/local/share/nvim/site/after,/home/burp/.local/share/nvim/site/after,/etc/xdg/nvim/after,/home/burp/.config/nvim/after"
Searching for "/home/burp/.config/nvim/pack/*/opt/matchit"
Searching for "/etc/xdg/nvim/pack/*/opt/matchit"
Searching for "/home/burp/.local/share/nvim/site/pack/*/opt/matchit"
Searching for "/usr/local/share/nvim/site/pack/*/opt/matchit"
Searching for "/usr/share/nvim/site/pack/*/opt/matchit"
Searching for "/usr/share/nvim/runtime/pack/*/opt/matchit"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/.config/nvim)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/.vim/bundle/Vundle.vim)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/.vim/bundle/YouCompleteMe)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/.vim/bundle/vim-fugitive)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/.vim/bundle/vim-tmux-navigator)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/etc/xdg/nvim)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/.local/share/nvim/site)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/local/share/nvim/site)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/site)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/pack/dist/opt)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/pack/dist/opt/matchit/plugin)
chdir(/home/burp/Applications/.bash_aliases)
line 3: sourcing "/usr/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim"
line 1: "  matchit.vim: (global plugin) Extended "%" matching
line 2: "  Maintainer:  Christian Brabandt
line 3: "  Version:     1.18
line 4: "  Last Change: 2020 Dec 23
line 5: "  Repository:  https://github.com/chrisbra/matchit
line 6: "  Previous URL:http://www.vim.org/script.php?script_id=39
line 7: "  Previous Maintainer:  Benji Fisher PhD   <benji@member.AMS.org>
line 8: 
line 9: " Documentation:
line 10: "  The documentation is in a separate file: ../doc/matchit.txt
line 11: 
line 12: " Credits:
line 13: "  Vim editor by Bram Moolenaar (Thanks, Bram!)
line 14: "  Original script and design by Raul Segura Acevedo
line 15: "  Support for comments by Douglas Potts
line 16: "  Support for back references and other improvements by Benji Fisher
line 17: "  Support for many languages by Johannes Zellner
line 18: "  Suggestions for improvement, bug reports, and support for additional
line 19: "  languages by Jordi-Albert Batalla, Neil Bird, Servatius Brandt, Mark
line 20: "  Collett, Stephen Wall, Dany St-Amant, Yuheng Xie, and Johannes Zellner.
line 21: 
line 22: " Debugging:
line 23: "  If you'd like to try the built-in debugging commands...
line 24: "   :MatchDebug      to activate debugging for the current buffer
line 25: "  This saves the values of several key script variables as buffer-local
line 26: "  variables.  See the MatchDebug() function, below, for details.
line 27: 
line 28: " TODO:  I should think about multi-line patterns for b:match_words.
line 29: "   This would require an option:  how many lines to scan (default 1).
line 30: "   This would be useful for Python, maybe also for *ML.
line 31: " TODO:  Maybe I should add a menu so that people will actually use some of
line 32: "   the features that I have implemented.
line 33: " TODO:  Eliminate the MultiMatch function.  Add yet another argument to
line 34: "   Match_wrapper() instead.
line 35: " TODO:  Allow :let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'
line 36: " TODO:  Make backrefs safer by using '\V' (very no-magic).
line 37: " TODO:  Add a level of indirection, so that custom % scripts can use my
line 38: "   work but extend it.
line 39: 
line 40: " Allow user to prevent loading and prevent duplicate loading.
line 41: if exists("g:loaded_matchit") || &cp
line 42:   finish
line 43: endif
line 44: let g:loaded_matchit = 1
line 45: 
line 46: let s:save_cpo = &cpo
line 47: set cpo&vim
line 48: 
line 49: nnoremap <silent> <Plug>(MatchitNormalForward)     :<C-U>call matchit#Match_wrapper('',1,'n')<CR>
line 50: nnoremap <silent> <Plug>(MatchitNormalBackward)    :<C-U>call matchit#Match_wrapper('',0,'n')<CR>
line 51: xnoremap <silent> <Plug>(MatchitVisualForward)     :<C-U>call matchit#Match_wrapper('',1,'v')<CR>:if col("''") != col("$") \| exe ":normal! m'" \| endif<cr>gv``
line 53: xnoremap <silent> <Plug>(MatchitVisualBackward)    :<C-U>call matchit#Match_wrapper('',0,'v')<CR>m'gv``
line 54: onoremap <silent> <Plug>(MatchitOperationForward)  :<C-U>call matchit#Match_wrapper('',1,'o')<CR>
line 55: onoremap <silent> <Plug>(MatchitOperationBackward) :<C-U>call matchit#Match_wrapper('',0,'o')<CR>
line 56: 
line 57: " Analogues of [{ and ]} using matching patterns:
line 58: nnoremap <silent> <Plug>(MatchitNormalMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>
line 59: nnoremap <silent> <Plug>(MatchitNormalMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>
line 60: xnoremap <silent> <Plug>(MatchitVisualMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>m'gv``
line 61: xnoremap <silent> <Plug>(MatchitVisualMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>m'gv``
line 62: onoremap <silent> <Plug>(MatchitOperationMultiBackward) :<C-U>call matchit#MultiMatch("bW", "o")<CR>
line 63: onoremap <silent> <Plug>(MatchitOperationMultiForward)  :<C-U>call matchit#MultiMatch("W",  "o")<CR>
line 64: 
line 65: " text object:
line 66: xmap <silent> <Plug>(MatchitVisualTextObject) <Plug>(MatchitVisualMultiBackward)o<Plug>(MatchitVisualMultiForward)
line 67: 
line 68: if !exists("g:no_plugin_maps")
line 69:   nmap <silent> %  <Plug>(MatchitNormalForward)
line 70:   nmap <silent> g% <Plug>(MatchitNormalBackward)
line 71:   xmap <silent> %  <Plug>(MatchitVisualForward)
line 72:   xmap <silent> g% <Plug>(MatchitVisualBackward)
line 73:   omap <silent> %  <Plug>(MatchitOperationForward)
line 74:   omap <silent> g% <Plug>(MatchitOperationBackward)
line 75: 
line 76:   " Analogues of [{ and ]} using matching patterns:
line 77:   nmap <silent> [% <Plug>(MatchitNormalMultiBackward)
line 78:   nmap <silent> ]% <Plug>(MatchitNormalMultiForward)
line 79:   xmap <silent> [% <Plug>(MatchitVisualMultiBackward)
line 80:   xmap <silent> ]% <Plug>(MatchitVisualMultiForward)
line 81:   omap <silent> [% <Plug>(MatchitOperationMultiBackward)
line 82:   omap <silent> ]% <Plug>(MatchitOperationMultiForward)
line 83: 
line 84:   " Text object
line 85:   xmap a% <Plug>(MatchitVisualTextObject)
line 86: endif
line 87: 
line 88: " Call this function to turn on debugging information.  Every time the main
line 89: " script is run, buffer variables will be saved.  These can be used directly
line 90: " or viewed using the menu items below.
line 91: if !exists(":MatchDebug")
line 92:   command! -nargs=0 MatchDebug call matchit#Match_debug()
line 93: endif
line 94: 
line 95: let &cpo = s:save_cpo
line 96: unlet s:save_cpo
line 97: 
line 98: " vim:sts=2:sw=2:et:
finished sourcing /usr/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim
continuing in /usr/share/nvim/runtime/plugin/matchit.vim
line 3: augroup filetypedetect
line 3: augroup END
Searching for "/usr/lib/nvim/pack/*/opt/matchit"
Searching for "/usr/share/nvim/site/after/pack/*/opt/matchit"
Searching for "/usr/local/share/nvim/site/after/pack/*/opt/matchit"
Searching for "/home/burp/.local/share/nvim/site/after/pack/*/opt/matchit"
Searching for "/etc/xdg/nvim/after/pack/*/opt/matchit"
Searching for "/home/burp/.config/nvim/after/pack/*/opt/matchit"
line 4: endif
finished sourcing /usr/share/nvim/runtime/plugin/matchit.vim
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/burp/Applications/.bash_aliases)
sourcing "/usr/share/nvim/runtime/plugin/matchparen.vim"
line 1: " Vim plugin for showing matching parens
line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2021 Apr 08
line 4: 
line 5: " Exit quickly when:
line 6: " - this plugin was already loaded (or disabled)
line 7: " - when 'compatible' is set
line 8: if exists("g:loaded_matchparen") || &cp
line 9:   finish
line 10: endif
line 11: let g:loaded_matchparen = 1
line 12: 
line 13: if !exists("g:matchparen_timeout")
line 14:   let g:matchparen_timeout = 300
line 15: endif
line 16: if !exists("g:matchparen_insert_timeout")
line 17:   let g:matchparen_insert_timeout = 60
line 18: endif
line 19: 
line 20: augroup matchparen
line 21:   " Replace all matchparen autocommands
line 22:   autocmd! CursorMoved,CursorMovedI,WinEnter,WinScrolled * call s:Highlight_Matching_Pair()
line 23:   autocmd! WinLeave * call s:Remove_Matches()
line 24:   if exists('##TextChanged')
line 25:     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
line 26:   endif
line 27: augroup END
line 28: 
line 29: " Skip the rest if it was already done.
line 30: if exists("*s:Highlight_Matching_Pair")
line 31:   finish
line 32: endif
line 33: 
line 34: let s:cpo_save = &cpo
line 35: set cpo-=C
line 36: 
line 37: " The function that is invoked (very often) to define a ":match" highlighting
line 38: " for any matching paren.
line 39: func s:Highlight_Matching_Pair()
line 195: 
line 196: func s:Remove_Matches()
line 202: 
line 203: 
line 204: " Define commands that will disable and enable the plugin.
line 205: command DoMatchParen call s:DoMatchParen()
line 206: command NoMatchParen call s:NoMatchParen()
line 207: 
line 208: func s:NoMatchParen()
line 215: 
line 216: func s:DoMatchParen()
line 222: 
line 223: let &cpo = s:cpo_save
line 224: unlet s:cpo_save
finished sourcing /usr/share/nvim/runtime/plugin/matchparen.vim
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/burp/Applications/.bash_aliases)
sourcing "/usr/share/nvim/runtime/plugin/netrwPlugin.vim"
line 1: " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
line 2: "            PLUGIN SECTION
line 3: " Date:^I^IFeb 09, 2021
line 4: " Maintainer:^ICharles E Campbell <NcampObell@SdrPchip.AorgM-NOSPAM>
line 5: " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
line 6: " Copyright:    Copyright (C) 1999-2021 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like anything else that's free,
line 10: "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
line 11: "               *as is* and comes with no warranty of any kind, either
line 12: "               expressed or implied. By using this plugin, you agree that
line 13: "               in no event will the copyright holder be liable for any damages
line 14: "               resulting from the use of this software.
line 15: "
line 16: "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
line 17: "  (James 1:22 RSV)
line 18: " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
line 19: " Load Once: {{{1
line 20: if &cp || exists("g:loaded_netrwPlugin")
line 21:  finish
line 22: endif
line 23: let g:loaded_netrwPlugin = "v171"
line 24: let s:keepcpo = &cpo
line 25: set cpo&vim
line 26: "DechoRemOn
line 27: 
line 28: " ---------------------------------------------------------------------
line 29: " Public Interface: {{{1
line 30: 
line 31: " Local Browsing Autocmds: {{{2
line 32: augroup FileExplorer
line 33:  au!
line 34:  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
line 35:  au BufEnter *^Isil call s:LocalBrowse(expand("<amatch>"))
line 36:  au VimEnter *^Isil call s:VimEnter(expand("<amatch>"))
line 37:  if has("win32") || has("win95") || has("win64") || has("win16")
line 38:   au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
line 39:  endif
line 40: augroup END
line 41: 
line 42: " Network Browsing Reading Writing: {{{2
line 43: augroup Network
line 44:  au!
line 45:  au BufReadCmd   file://*^I^I^I^I^I^I^I^I^I^I^Icall netrw#FileUrlEdit(expand("<amatch>"))
line 46:  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
line 47:  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
line 48:  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
line 49:  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
line 50:  try
line 51:   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 52:  catch /^Vim\%((\a\+)\)\=:E216/
line 53:   au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 54:  endtry
line 55: augroup END
line 56: 
line 57: " Commands: :Nread, :Nwrite, :NetUserPass {{{2
line 58: com! -count=1 -nargs=*^INread^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
line 59: com! -range=% -nargs=*^INwrite^I^Ilet s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
line 60: com! -nargs=*^I^INetUserPass^Icall NetUserPass(<f-args>)
line 61: com! -nargs=*^I        Nsource^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
line 62: com! -nargs=?^I^INtree^I^Icall netrw#SetTreetop(1,<q-args>)
line 63: 
line 64: " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
line 65: com! -nargs=* -bar -bang -count=0 -complete=dir^IExplore^I^Icall netrw#Explore(<count>,0,0+<bang>0,<q-args>)
line 66: com! -nargs=* -bar -bang -count=0 -complete=dir^ISexplore^Icall netrw#Explore(<count>,1,0+<bang>0,<q-args>)
line 67: com! -nargs=* -bar -bang -count=0 -complete=dir^IHexplore^Icall netrw#Explore(<count>,1,2+<bang>0,<q-args>)
line 68: com! -nargs=* -bar -bang -count=0 -complete=dir^IVexplore^Icall netrw#Explore(<count>,1,4+<bang>0,<q-args>)
line 69: com! -nargs=* -bar       -count=0 -complete=dir^ITexplore^Icall netrw#Explore(<count>,0,6        ,<q-args>)
line 70: com! -nargs=* -bar -bang^I^I^INexplore^Icall netrw#Explore(-1,0,0,<q-args>)
line 71: com! -nargs=* -bar -bang^I^I^IPexplore^Icall netrw#Explore(-2,0,0,<q-args>)
line 72: com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore^Icall netrw#Lexplore(<count>,<bang>0,<q-args>)
line 73: 
line 74: " Commands: NetrwSettings {{{2
line 75: com! -nargs=0^INetrwSettings^Icall netrwSettings#NetrwSettings()
line 76: com! -bang^INetrwClean^Icall netrw#Clean(<bang>0)
line 77: 
line 78: " Maps:
line 79: if !exists("g:netrw_nogx")
line 80:  if maparg('gx','n') == ""
line 81:   if !hasmapto('<Plug>NetrwBrowseX')
line 82:    nmap <unique> gx <Plug>NetrwBrowseX
line 83:   endif
line 84:   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(netrw#GX(),netrw#CheckIfRemote(netrw#GX()))<cr>
line 85:  endif
line 86:  if maparg('gx','x') == ""
line 87:   if !hasmapto('<Plug>NetrwBrowseXVis')
line 88:    xmap <unique> gx <Plug>NetrwBrowseXVis
line 89:   endif
line 90:   xno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
line 91:  endif
line 92: endif
line 93: if exists("g:netrw_usetab") && g:netrw_usetab
line 94:  if maparg('<c-tab>','n') == ""
line 95:   nmap <unique> <c-tab> <Plug>NetrwShrink
line 96:  endif
line 97:  nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
line 98: endif
line 99: 
line 100: " ---------------------------------------------------------------------
line 101: " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
line 102: fun! s:LocalBrowse(dirname)
line 146: 
line 147: " ---------------------------------------------------------------------
line 148: " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
line 149: "             Its purpose: to look over all windows and run s:LocalBrowse() on
line 150: "             them, which checks if they're directories and will create a directory
line 151: "             listing when appropriate.
line 152: "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
line 153: "             has already been called.
line 154: fun! s:VimEnter(dirname)
line 174: 
line 175: " ---------------------------------------------------------------------
line 176: " NetrwStatusLine: {{{1
line 177: fun! NetrwStatusLine()
line 188: 
line 189: " ------------------------------------------------------------------------
line 190: " NetUserPass: set username and password for subsequent ftp transfer {{{1
line 191: "   Usage:  :call NetUserPass()^I^I^I-- will prompt for userid and password
line 192: "^I    :call NetUserPass("uid")^I^I-- will prompt for password
line 193: "^I    :call NetUserPass("uid","password") -- sets global userid and password
line 194: fun! NetUserPass(...)
line 218: 
line 219: " ------------------------------------------------------------------------
line 220: " Modelines And Restoration: {{{1
line 221: let &cpo= s:keepcpo
line 222: unlet s:keepcpo
line 223: " vim:ts=8 fdm=marker
finished sourcing /usr/share/nvim/runtime/plugin/netrwPlugin.vim
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/burp/Applications/.bash_aliases)
sourcing "/usr/share/nvim/runtime/plugin/rplugin.vim"
line 1: if exists('g:loaded_remote_plugins')
line 2:   finish
line 3: endif
line 4: let g:loaded_remote_plugins = '/path/to/manifest'
line 5: 
line 6: " Get the path to the rplugin manifest file.
line 7: function! s:GetManifestPath() abort
line 24: 
line 25: " Old manifest file based on known script locations.
line 26: function! s:GetOldManifestPaths() abort
line 41: 
line 42: function! s:GetManifest() abort
line 55: 
line 56: function! s:LoadRemotePlugins() abort
line 62: 
line 63: command! -bar UpdateRemotePlugins call remote#host#UpdateRemotePlugins()
line 64: 
line 65: if index(v:argv, "--clean") < 0
line 66:   call s:LoadRemotePlugins()
calling <SNR>30_LoadRemotePlugins()

line 1:   let g:loaded_remote_plugins = s:GetManifest()
calling <SNR>30_GetManifest()

line 1:   let manifest = s:GetManifestPath()
calling <SNR>30_GetManifestPath()

line 1:   let manifest_base = ''
line 2: 
line 3:   if exists('$NVIM_RPLUGIN_MANIFEST')
line 4:     return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')
line 5:   endif
line 6: 
line 7:   let dest = stdpath('data')
line 8:   if !empty(dest)
line 9:     if !isdirectory(dest)
line 10:       call mkdir(dest, 'p', 0700)
line 11:     endif
line 12:     let manifest_base = dest
line 13:   endif
line 14: 
line 15:   return manifest_base.'/rplugin.vim'
<SNR>30_GetManifestPath returning '/home/burp/.local/share/nvim/rplugin.vim'

continuing in <SNR>30_GetManifest

line 2:   if !filereadable(manifest)
line 3:     " Check if an old manifest file exists and move it to the new location.
line 4:     for old_manifest in s:GetOldManifestPaths()
line 5:       if filereadable(old_manifest)
line 6:         call rename(old_manifest, manifest)
line 7:         break
line 8:       endif
line 9:     endfor
line 10:   endif
line 11:   return manifest
<SNR>30_GetManifest returning '/home/burp/.local/share/nvim/rplugin.vim'

continuing in <SNR>30_LoadRemotePlugins

line 2:   if filereadable(g:loaded_remote_plugins)
line 3:     execute 'source' fnameescape(g:loaded_remote_plugins)
line 3: source /home/burp/.local/share/nvim/rplugin.vim
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/.local/share/nvim)
chdir(/home/burp/Applications/.bash_aliases)
line 3: sourcing "/home/burp/.local/share/nvim/rplugin.vim"
line 1: " perl plugins
line 2: 
line 3: 
line 4: " node plugins
line 5: 
line 6: 
line 7: " python3 plugins
line 8: 
line 9: 
line 10: " ruby plugins
line 11: 
line 12: 
line 13: " python plugins
line 14: 
line 15: 
finished sourcing /home/burp/.local/share/nvim/rplugin.vim
continuing in <SNR>30_LoadRemotePlugins
line 4:   endif
<SNR>30_LoadRemotePlugins returning #0

continuing in /usr/share/nvim/runtime/plugin/rplugin.vim

line 67: endif
finished sourcing /usr/share/nvim/runtime/plugin/rplugin.vim
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/burp/Applications/.bash_aliases)
sourcing "/usr/share/nvim/runtime/plugin/shada.vim"
line 1: if exists('g:loaded_shada_plugin')
line 2:   finish
line 3: endif
line 4: let g:loaded_shada_plugin = 1
line 5: 
line 6: augroup ShaDaCommands
line 7:   autocmd!
line 8:   autocmd BufReadCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call setline('.', shada#get_strings(readfile(expand('<afile>'),'b'))) |setlocal filetype=shada
line 12:   autocmd FileReadCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call append("'[", shada#get_strings(readfile(expand('<afile>'), 'b')))
line 15:   autocmd BufWriteCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |if writefile(shada#get_binstrings(getline(1, '$')),expand('<afile>'), 'b') == 0 |  let &l:modified = (expand('<afile>') is# bufname(+expand('<abuf>'))? 0: stridx(&cpoptions, '+') != -1) |endif
line 23:   autocmd FileWriteCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call writefile(shada#get_binstrings(getline(min([line("'["), line("']")]),max([line("'["), line("']")]))),expand('<afile>'),'b')
line 30:   autocmd FileAppendCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call writefile(shada#get_binstrings(getline(min([line("'["), line("']")]),max([line("'["), line("']")]))),expand('<afile>'),'ab')
line 37:   autocmd SourceCmd *.shada,*.shada.tmp.[a-z] :execute 'rshada' fnameescape(expand('<afile>'))
line 39: augroup END
finished sourcing /usr/share/nvim/runtime/plugin/shada.vim
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/burp/Applications/.bash_aliases)
sourcing "/usr/share/nvim/runtime/plugin/spellfile.vim"
line 1: " Vim plugin for downloading spell files
line 2: 
line 3: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
line 4:   finish
line 5: endif
line 6: let loaded_spellfile_plugin = 1
line 7: 
line 8: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))
finished sourcing /usr/share/nvim/runtime/plugin/spellfile.vim
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/burp/Applications/.bash_aliases)
sourcing "/usr/share/nvim/runtime/plugin/tarPlugin.vim"
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles
line 2: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
line 3: " Modified by Charles E. Campbell
line 4: " Distributed under the GNU General Public License.
line 5: "
line 6: " Updates are available from <http://michael.toren.net/code/>.  If you
line 7: " find this script useful, or have suggestions for improvements, please
line 8: " let me know.
line 9: " Also look there for further comments and documentation.
line 10: "
line 11: " This part only sets the autocommands.  The functions are in autoload/tar.vim.
line 12: " ---------------------------------------------------------------------
line 13: "  Load Once: {{{1
line 14: if &cp || exists("g:loaded_tarPlugin")
line 15:  finish
line 16: endif
line 17: let g:loaded_tarPlugin = "v32"
line 18: let s:keepcpo          = &cpo
line 19: set cpo&vim
line 20: 
line 21: " ---------------------------------------------------------------------
line 22: "  Public Interface: {{{1
line 23: augroup tar
line 24:   au!
line 25:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)
line 26:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)
line 27:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))
line 28:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))
line 29: 
line 30:   if has("unix")
line 31:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)
line 32:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)
line 33:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 34:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 35:   endif
line 36: 
line 37:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))
line 38:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))
line 39:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))
line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))
line 41:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))
line 42:   au BufReadCmd   *.tbz^I^I^Icall tar#Browse(expand("<amatch>"))
line 43:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))
line 44:   au BufReadCmd   *.tar.lzma^Icall tar#Browse(expand("<amatch>"))
line 45:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))
line 46:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))
line 47:   au BufReadCmd   *.tar.zst^I^Icall tar#Browse(expand("<amatch>"))
line 48:   au BufReadCmd   *.tzs^I^I^Icall tar#Browse(expand("<amatch>"))
line 49: augroup END
line 50: com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
line 51: 
line 52: " ---------------------------------------------------------------------
line 53: " Restoration And Modelines: {{{1
line 54: " vim: fdm=marker
line 55: let &cpo= s:keepcpo
line 56: unlet s:keepcpo
finished sourcing /usr/share/nvim/runtime/plugin/tarPlugin.vim
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/burp/Applications/.bash_aliases)
sourcing "/usr/share/nvim/runtime/plugin/tohtml.vim"
line 1: " Vim plugin for converting a syntax highlighted file to HTML.
line 2: " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
line 3: " Last Change: 2019 Nov 13
line 4: "
line 5: " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
line 6: " $VIMRUNTIME/syntax/2html.vim
line 7: "
line 8: if exists('g:loaded_2html_plugin')
line 9:   finish
line 10: endif
line 11: let g:loaded_2html_plugin = 'vim8.1_v2'
line 12: 
line 13: "
line 14: " Changelog: {{{
line 15: "   8.1_v2  (this version): - Fix Bitbucket issue #19: fix calculation of tab
line 16: "                             stop position to use in expanding a tab, when that
line 17: "                             tab occurs after a syntax match which in turn
line 18: "                             comes after previously expanded tabs.
line 19: "                           - Set eventignore while splitting a window for the
line 20: "                             destination file to ignore FileType events;
line 21: "                             speeds up processing when the destination file
line 22: "                             already exists and HTML highlight takes too long.
line 23: "                           - Fix Bitbucket issue #20: progress bar could not be
line 24: "                             seen when DiffDelete background color matched
line 25: "                             StatusLine background color. Added TOhtmlProgress
line 26: "                             highlight group for manual user override, but
line 27: "                             calculate it to be visible compared to StatusLine
line 28: "                             by default.
line 29: "                           - Fix Bitbucket issue #1: Remove workaround for old
line 30: "                             browsers which don't support 'ch' CSS unit, since
line 31: "                             all modern browsers, including IE>=9, support it.
line 32: "                           - Fix Bitbucket issue #10: support termguicolors
line 33: "                           - Fix Bitbucket issue #21: default to using
line 34: "                             generated content instead of <input> tags for
line 35: "                             uncopyable text, so that text is correctly
line 36: "                             prevented from being copied in chrome. Use
line 37: "                             g:html_use_input_for_pc option to control the
line 38: "                             method used.
line 39: "                           - Switch to HTML5 to allow using vnu as a validator
line 40: "                             in unit test.
line 41: "                           - Fix fallback sizing of <input> tags for browsers
line 42: "                             without "ch" support.
line 43: "                           - Fix cursor on unselectable diff filler text.
line 44: "   8.1_v1  (Vim 8.1.0528): - Fix Bitbucket issue #6: Don't generate empty
line 45: "                             script tag.
line 46: "                           - Fix Bitbucket issue #5: javascript should
line 47: "                             declare variables with "var".
line 48: "                           - Fix Bitbucket issue #13: errors thrown sourcing
line 49: "                             2html.vim directly when plugins not loaded.
line 50: "                           - Fix Bitbucket issue #16: support 'vartabstop'.
line 51: "
line 52: "   7.4 updates: {{{
line 53: "   7.4_v2  (Vim 7.4.0899): Fix error raised when converting a diff containing
line 54: "                           an empty buffer. Jan Stocker: allow g:html_font to
line 55: "                           take a list so it is easier to specfiy fallback
line 56: "                           fonts in the generated CSS.
line 57: "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and
line 58: "^I^I^I    also for version-specific modelines like "vim>703:".
line 59: "}}}
line 60: "
line 61: "   7.3 updates: {{{
line 62: "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using
line 63: "^I^I^I    g:html_line_ids=0. Allow customizing
line 64: "^I^I^I    important IDs (like line IDs and fold IDs) using
line 65: "^I^I^I    g:html_id_expr evaluated when the buffer conversion
line 66: "^I^I^I    is started.
line 67: "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and
line 68: "^I^I^I    insert modeline to set it to manual.
line 69: "^I^I^I    Fix bug: diff mode with 2 unsaved buffers creates a
line 70: "^I^I^I    duplicate of one buffer instead of including both.
line 71: "^I^I^I    Add anchors to each line so you can put '#L123'
line 72: "^I^I^I    or '#123' at the end of the URL to jump to line 123
line 73: "^I^I^I    (idea by Andy Spencer). Add javascript to open folds
line 74: "^I^I^I    to show the anchor being jumped to if it is hidden.
line 75: "^I^I^I    Fix XML validation error: &nsbp; not part of XML.
line 76: "^I^I^I    Allow TOhtml to chain together with other commands
line 77: "^I^I^I    using |.
line 78: "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple
line 79: "^I^I^I    highlight groups make up the start-of-modeline text.
line 80: "^I^I^I    Improve render time of page with uncopyable regions
line 81: "^I^I^I    by not using one-input-per-char. Change name of
line 82: "^I^I^I    uncopyable option from html_unselectable to
line 83: "^I^I^I    html_prevent_copy. Added html_no_invalid option and
line 84: "^I^I^I    default to inserting invalid markup for uncopyable
line 85: "^I^I^I    regions to prevent MS Word from pasting undeletable
line 86: "^I^I^I    <input> elements. Fix 'cpo' handling (Thilo Six).
line 87: "^I^I 7.3_v12b1: Add html_unselectable option. Rework logic to
line 88: "^I^I^I    eliminate post-processing substitute commands in
line 89: "^I^I^I    favor of doing the work up front. Remove unnecessary
line 90: "^I^I^I    special treatment of 'LineNr' highlight group. Minor
line 91: "^I^I^I    speed improvements. Fix modeline mangling in
line 92: "^I^I^I    generated output so it works for text in the first
line 93: "^I^I^I    column. Fix missing line number and fold column in
line 94: "^I^I^I    diff filler lines. Fix that some fonts have a 1px
line 95: "^I^I^I    gap (using a dirty hack, improvements welcome). Add
line 96: "^I^I^I    "colorscheme" meta tag. Does NOT include support for
line 97: "^I^I^I    the new default foldtext added in v11, as the patch
line 98: "^I^I^I    adding it has not yet been included in Vim.
line 99: "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian
line 100: "^I^I^I    Brabandt in
line 101: "^I^I^I    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.
line 102: "^I^I^I    This patch has not yet been included in Vim, thus
line 103: "^I^I^I    these changes are removed in the next version.
line 104: "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside
line 105: "^I^I^I    multiple nested folds with dynamic folding on.
line 106: "^I^I^I    Also fix problem with foldtext in this situation.
line 107: "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css
line 108: "^I^I^I    and without html_no_pre, default value same as
line 109: "^I^I^I    'wrap' option, (Andy Spencer). Don't use
line 110: "^I^I^I    'fileencoding' for converted document encoding if
line 111: "^I^I^I    'buftype' indicates a special buffer which isn't
line 112: "^I^I^I    written.
line 113: "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab
line 114: "^I^I^I    characters in generated output (Andy Spencer).
line 115: "^I^I^I    Escape text that looks like a modeline so Vim
line 116: "^I^I^I    doesn't use anything in the converted HTML as a
line 117: "^I^I^I    modeline. Bugfixes: Fix folding when a fold starts
line 118: "^I^I^I    before the conversion range. Remove fold column when
line 119: "^I^I^I    there are no folds.
line 120: "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:
line 121: "^I^I  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
line 122: "^I^I  7.3_v7b2: Remove automatic detection of encodings that are not
line 123: "^I^I^I    supported by all major browsers according to
line 124: "^I^I^I    http://wiki.whatwg.org/wiki/Web_Encodings and
line 125: "^I^I^I    convert to UTF-8 for all Unicode encodings. Make
line 126: "^I^I^I    HTML encoding to Vim encoding detection be
line 127: "^I^I^I    case-insensitive for built-in pairs.
line 128: "^I^I  7.3_v7b1: Remove use of setwinvar() function which cannot be
line 129: "^I^I^I    called in restricted mode (Andy Spencer). Use
line 130: "^I^I^I    'fencoding' instead of 'encoding' to determine by
line 131: "^I^I^I    charset, and make sure the 'fenc' of the generated
line 132: "^I^I^I    file matches its indicated charset. Add charsets for
line 133: "^I^I^I    all of Vim's natively supported encodings.
line 134: "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other
line 135: "^I^I^I    user settings interfering with diff mode generation,
line 136: "^I^I^I    trailing whitespace (e.g. line number column) when
line 137: "^I^I^I    using html_no_pre, and bugs when using
line 138: "^I^I^I    html_hover_unfold.
line 139: "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
line 140: "^I^I^I    folds in diff mode when first line was folded.
line 141: "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode
line 142: "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css
line 143: "^I^I^I    default to true when not set to anything. Use strict
line 144: "^I^I^I    doctypes where possible. Rename use_xhtml option to
line 145: "^I^I^I    html_use_xhtml for consistency. Use .xhtml extension
line 146: "^I^I^I    when using this option. Add meta tag for settings.
line 147: "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the
line 148: "^I^I^I    diff colors and the normal syntax colors
line 149: "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output
line 150: "}}}
line 151: "}}}
line 152: 
line 153: " TODO: {{{
line 154: "   * Check the issue tracker:
line 155: "     https://bitbucket.org/fritzophrenic/vim-tohtml/issues?status=new&status=open
line 156: "   * Options for generating the CSS in external style sheets. New :TOcss
line 157: "     command to convert the current color scheme into a (mostly) generic CSS
line 158: "     stylesheet which can be re-used. Alternate stylesheet support? Good start
line 159: "     by Erik Falor
line 160: "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).
line 161: "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,
line 162: "     term) to use for the styling. Suggestion by "nacitar".
line 163: "   * Add way to override or specify which RGB colors map to the color numbers
line 164: "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".
line 165: "   * Disable filetype detection until after all processing is done.
line 166: "   * Add option for not generating the hyperlink on stuff that looks like a
line 167: "     URL? Or just color the link to fit with the colorscheme (and only special
line 168: "     when hovering)?
line 169: "   * Bug: Opera does not allow printing more than one page if uncopyable
line 170: "     regions is turned on. Possible solution: Add normal text line numbers with
line 171: "     display:none, set to display:inline for print style sheets, and hide
line 172: "     <input> elements for print, to allow Opera printing multiple pages (and
line 173: "     other uncopyable areas?). May need to make the new text invisible to IE
line 174: "     with conditional comments to prevent copying it, IE for some reason likes
line 175: "     to copy hidden text. Other browsers too?
line 176: "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is
line 177: "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome
line 178: "     on Windows). Perhaps it is font related?
line 179: "   * Bug: still some gaps in the fold column when html_prevent_copy contains
line 180: "     'd' and showing the whole diff (observed in multiple browsers). Only gaps
line 181: "     on diff lines though.
line 182: "   * Undercurl support via CSS3, with fallback to dotted or something:
line 183: "^Ihttps://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion
line 184: "   * Redo updates for modified default foldtext (v11) when/if the patch is
line 185: "     accepted to modify it.
line 186: "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold
line 187: "^I^I+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress
line 188: "^I^I+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml
line 189: "     does not show the whole diff filler as it is supposed to?
line 190: "   * Bug: when 'isprint' is wrong for the current encoding, will generate
line 191: "     invalid content. Can/should anything be done about this? Maybe a separate
line 192: "     plugin to correct 'isprint' based on encoding?
line 193: "   * Check to see if the windows-125\d encodings actually work in Unix without
line 194: "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.
line 195: "   * Font auto-detection similar to
line 196: "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of
line 197: "     platforms.
line 198: "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
line 199: "^I- listchars support
line 200: "^I- full-line background highlight
line 201: "^I- other?
line 202: "   * Make it so deleted lines in a diff don't create side-scrolling (get it
line 203: "     free with full-line background highlight above).
line 204: "   * Restore open/closed folds and cursor position after processing each file
line 205: "     with option not to restore for speed increase.
line 206: "   * Add extra meta info (generation time, etc.)?
line 207: "   * Tidy up so we can use strict doctype in even more situations
line 208: "   * Implementation detail: add threshold for writing the lines to the html
line 209: "     buffer before we're done (5000 or so lines should do it)
line 210: "   * TODO comments for code cleanup scattered throughout
line 211: "}}}
line 212: 
line 213: " Define the :TOhtml command when:
line 214: " - 'compatible' is not set
line 215: " - this plugin or user override was not already loaded
line 216: " - user commands are available. {{{
line 217: if !&cp && !exists(":TOhtml") && has("user_commands")
line 218:   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
line 219: endif "}}}
line 220: 
line 221: " Make sure any patches will probably use consistent indent
line 222: "   vim: ts=8 sw=2 sts=2 noet fdm=marker
finished sourcing /usr/share/nvim/runtime/plugin/tohtml.vim
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/burp/Applications/.bash_aliases)
sourcing "/usr/share/nvim/runtime/plugin/tutor.vim"
line 1: if exists('g:loaded_tutor_mode_plugin') || &compatible
line 2:     finish
line 3: endif
line 4: let g:loaded_tutor_mode_plugin = 1
line 5: 
line 6: command! -nargs=? -complete=custom,tutor#TutorCmdComplete Tutor call tutor#TutorCmd(<q-args>)
finished sourcing /usr/share/nvim/runtime/plugin/tutor.vim
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/burp/Applications/.bash_aliases)
sourcing "/usr/share/nvim/runtime/plugin/zipPlugin.vim"
line 1: " zipPlugin.vim: Handles browsing zipfiles
line 2: "            PLUGIN PORTION
line 3: " Date:^I^I^IJan 07, 2020
line 4: " Maintainer:^ICharles E Campbell <NcampObell@SdrPchip.AorgM-NOSPAM>
line 5: " License:^I^IVim License  (see vim's :help license)
line 6: " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like anything else that's free,
line 10: "               zipPlugin.vim is provided *as is* and comes with no warranty
line 11: "               of any kind, either expressed or implied. By using this
line 12: "               plugin, you agree that in no event will the copyright
line 13: "               holder be liable for any damages resulting from the use
line 14: "               of this software.
line 15: "
line 16: " (James 4:8 WEB) Draw near to God, and he will draw near to you.
line 17: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
line 18: " ---------------------------------------------------------------------
line 19: " Load Once: {{{1
line 20: if &cp || exists("g:loaded_zipPlugin")
line 21:  finish
line 22: endif
line 23: let g:loaded_zipPlugin = "v32"
line 24: let s:keepcpo          = &cpo
line 25: set cpo&vim
line 26: 
line 27: " ---------------------------------------------------------------------
line 28: " Options: {{{1
line 29: if !exists("g:zipPlugin_ext")
line 30:  let g:zipPlugin_ext='*.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
line 31: endif
line 32: 
line 33: " ---------------------------------------------------------------------
line 34: " Public Interface: {{{1
line 35: augroup zip
line 36:  au!
line 37:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)
line 38:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)
line 39:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))
line 40:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))
line 41: 
line 42:  if has("unix")
line 43:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)
line 44:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)
line 45:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 46:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 47:  endif
line 48: 
line 49:  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
line 49: au BufReadCmd *.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip call zip#Browse(expand("<amatch>"))
line 50: augroup END
line 51: 
line 52: " ---------------------------------------------------------------------
line 53: "  Restoration And Modelines: {{{1
line 54: "  vim: fdm=marker
line 55: let &cpo= s:keepcpo
line 56: unlet s:keepcpo
finished sourcing /usr/share/nvim/runtime/plugin/zipPlugin.vim
Searching for "/usr/lib/nvim/plugin/**/*.vim"
Searching for "/usr/share/vim/vimfiles/plugin/**/*.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/vim/vimfiles/plugin)
chdir(/home/burp/Applications/.bash_aliases)
sourcing "/usr/share/vim/vimfiles/plugin/fzf.vim"
line 1: " Copyright (c) 2017 Junegunn Choi
line 2: "
line 3: " MIT License
line 4: "
line 5: " Permission is hereby granted, free of charge, to any person obtaining
line 6: " a copy of this software and associated documentation files (the
line 7: " "Software"), to deal in the Software without restriction, including
line 8: " without limitation the rights to use, copy, modify, merge, publish,
line 9: " distribute, sublicense, and/or sell copies of the Software, and to
line 10: " permit persons to whom the Software is furnished to do so, subject to
line 11: " the following conditions:
line 12: "
line 13: " The above copyright notice and this permission notice shall be
line 14: " included in all copies or substantial portions of the Software.
line 15: "
line 16: " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
line 17: " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
line 18: " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
line 19: " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
line 20: " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
line 21: " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
line 22: " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
line 23: 
line 24: if exists('g:loaded_fzf')
line 25:   finish
line 26: endif
line 27: let g:loaded_fzf = 1
line 28: 
line 29: let s:is_win = has('win32') || has('win64')
line 30: if s:is_win && &shellslash
line 31:   set noshellslash
line 32:   let s:base_dir = expand('<sfile>:h:h')
line 33:   set shellslash
line 34: else
line 35:   let s:base_dir = expand('<sfile>:h:h')
line 36: endif
line 37: if s:is_win
line 38:   let s:term_marker = '&::FZF'
line 39: 
line 40:   function! s:fzf_call(fn, ...)
line 49: 
line 50:   " Use utf-8 for fzf.vim commands
line 51:   " Return array of shell commands for cmd.exe
line 52:   function! s:enc_to_cp(str)
line 61:   function! s:wrap_cmds(cmds)
line 70: else
line 71:   let s:term_marker = ";#FZF"
line 72: 
line 73:   function! s:fzf_call(fn, ...)
line 76: 
line 77:   function! s:wrap_cmds(cmds)
line 80: 
line 81:   function! s:enc_to_cp(str)
line 84: endif
line 85: 
line 86: function! s:shellesc_cmd(arg)
line 93: 
line 94: function! fzf#shellescape(arg, ...)
line 106: 
line 107: function! s:fzf_getcwd()
line 110: 
line 111: function! s:fzf_fnamemodify(fname, mods)
line 114: 
line 115: function! s:fzf_expand(fmt)
line 118: 
line 119: function! s:fzf_tempname()
line 122: 
line 123: let s:layout_keys = ['window', 'tmux', 'up', 'down', 'left', 'right']
line 124: let s:fzf_go = s:base_dir.'/bin/fzf'
line 125: let s:fzf_tmux = s:base_dir.'/bin/fzf-tmux'
line 126: 
line 127: let s:cpo_save = &cpo
line 128: set cpo&vim
line 129: 
line 130: function! s:popup_support()
line 133: 
line 134: function! s:default_layout()
line 139: 
line 140: function! fzf#install()
line 161: 
line 162: let s:versions = {}
line 163: function s:get_version(bin)
line 176: 
line 177: function! s:compare_versions(a, b)
line 189: 
line 190: function! s:compare_binary_versions(a, b)
line 193: 
line 194: let s:checked = {}
line 195: function! fzf#exec(...)
line 245: 
line 246: function! s:tmux_enabled()
line 268: 
line 269: function! s:escape(path)
line 273: 
line 274: function! s:error(msg)
line 279: 
line 280: function! s:warn(msg)
line 285: 
line 286: function! s:has_any(dict, keys)
line 294: 
line 295: function! s:open(cmd, target)
line 301: 
line 302: function! s:common_sink(action, lines) abort
line 343: 
line 344: function! s:get_color(attr, ...)
line 357: 
line 358: function! s:defaults()
line 363: 
line 364: function! s:validate_layout(layout)
line 373: 
line 374: function! s:evaluate_opts(options)
line 378: 
line 379: " [name string,] [opts dict,] [fullscreen boolean]
line 380: function! fzf#wrap(...)
line 439: 
line 440: function! s:use_sh()
line 452: 
line 453: function! s:writefile(...)
line 458: 
line 459: function! fzf#run(...) abort
line 541: 
line 542: function! s:present(dict, ...)
line 550: 
line 551: function! s:fzf_tmux(dict)
line 570: 
line 571: function! s:splittable(dict)
line 575: 
line 576: function! s:pushd(dict)
line 592: 
line 593: augroup fzf_popd
line 594:   autocmd!
line 595:   autocmd WinEnter * call s:dopopd()
line 596: augroup END
line 597: 
line 598: function! s:dopopd()
line 623: 
line 624: function! s:xterm_launcher()
line 633: unlet! s:launcher
line 634: if s:is_win || has('win32unix')
line 635:   let s:launcher = '%s'
line 636: else
line 637:   let s:launcher = function('s:xterm_launcher')
line 638: endif
line 639: 
line 640: function! s:exit_handler(code, command, ...)
line 656: 
line 657: function! s:execute(dict, command, use_height, temps) abort
line 707: 
line 708: function! s:execute_tmux(dict, command, temps) abort
line 722: 
line 723: function! s:calc_size(max, val, dict)
line 747: 
line 748: function! s:getpos()
line 751: 
line 752: function! s:border_opt(window)
line 777: 
line 778: function! s:split(dict)
line 822: 
line 823: nnoremap <silent> <Plug>(fzf-insert) i
line 824: nnoremap <silent> <Plug>(fzf-normal) <Nop>
line 825: if exists(':tnoremap')
line 826:   tnoremap <silent> <Plug>(fzf-insert) <C-\><C-n>i
line 827:   tnoremap <silent> <Plug>(fzf-normal) <C-\><C-n>
line 828: endif
line 829: 
line 830: function! s:execute_term(dict, command, temps) abort
line 930: 
line 931: function! s:collect(temps) abort
line 940: 
line 941: function! s:callback(dict, lines) abort
line 974: 
line 975: if has('nvim')
line 976:   function s:create_popup(opts) abort
line 984: else
line 985:   function! s:create_popup(opts) abort
line 997: endif
line 998: 
line 999: function! s:popup(opts) abort
line 1024: 
line 1025: let s:default_action = { 'ctrl-t': 'tab split', 'ctrl-x': 'split', 'ctrl-v': 'vsplit' }
line 1029: 
line 1030: function! s:shortpath()
line 1038: 
line 1039: function! s:cmd(bang, ...) abort
line 1056: 
line 1057: command! -nargs=* -complete=dir -bang FZF call s:cmd(<bang>0, <f-args>)
line 1058: 
line 1059: let &cpo = s:cpo_save
line 1060: unlet s:cpo_save
finished sourcing /usr/share/vim/vimfiles/plugin/fzf.vim
Searching for "/home/burp/.vim/bundle/Vundle.vim/plugin/**/*.vim"
Searching for "plugin/**/*.lua" in "/home/burp/.config/nvim,/home/burp/.vim/bundle/Vundle.vim,/home/burp/.vim/bundle/YouCompleteMe,/home/burp/.vim/bundle/vim-fugitive,/home/burp/.vim/bundle/vim-tmux-navigator,/etc/xdg/nvim,/home/burp/.local/share/nvim/site,/usr/local/share/nvim/site,/usr/share/nvim/site,/usr/share/nvim/runtime,/usr/lib/nvim,/usr/share/nvim/site/after,/usr/local/share/nvim/site/after,/home/burp/.local/share/nvim/site/after,/etc/xdg/nvim/after,/home/burp/.config/nvim/after,/usr/share/vim/vimfiles,/home/burp/.vim/bundle/Vundle.vim,/home/burp/.vim/bundle/Vundle.vim/after,/home/burp/.vim/bundle/YouCompleteMe/after,/home/burp/.vim/bundle/vim-fugitive/after,/home/burp/.vim/bundle/vim-tmux-navigator/after"
Searching for "/home/burp/.config/nvim/plugin/**/*.lua"
Searching for "/home/burp/.vim/bundle/Vundle.vim/plugin/**/*.lua"
Searching for "/home/burp/.vim/bundle/YouCompleteMe/plugin/**/*.lua"
Searching for "/home/burp/.vim/bundle/vim-fugitive/plugin/**/*.lua"
Searching for "/home/burp/.vim/bundle/vim-tmux-navigator/plugin/**/*.lua"
Searching for "/etc/xdg/nvim/plugin/**/*.lua"
Searching for "/home/burp/.local/share/nvim/site/plugin/**/*.lua"
Searching for "/usr/local/share/nvim/site/plugin/**/*.lua"
Searching for "/usr/share/nvim/site/plugin/**/*.lua"
Searching for "/usr/share/nvim/runtime/plugin/**/*.lua"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/burp/Applications/.bash_aliases)
sourcing "/usr/share/nvim/runtime/plugin/man.lua"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/burp/Applications/.bash_aliases)
finished sourcing /usr/share/nvim/runtime/plugin/man.lua
Searching for "/usr/lib/nvim/plugin/**/*.lua"
Searching for "/usr/share/vim/vimfiles/plugin/**/*.lua"
Searching for "/home/burp/.vim/bundle/Vundle.vim/plugin/**/*.lua"
Searching for "pack/*/start/*" in "/home/burp/.config/nvim,/etc/xdg/nvim,/home/burp/.local/share/nvim/site,/usr/local/share/nvim/site,/usr/share/nvim/site,/usr/share/nvim/runtime,/usr/lib/nvim,/usr/share/nvim/site/after,/usr/local/share/nvim/site/after,/home/burp/.local/share/nvim/site/after,/etc/xdg/nvim/after,/home/burp/.config/nvim/after"
Searching for "/home/burp/.config/nvim/pack/*/start/*"
Searching for "/etc/xdg/nvim/pack/*/start/*"
Searching for "/home/burp/.local/share/nvim/site/pack/*/start/*"
Searching for "/usr/local/share/nvim/site/pack/*/start/*"
Searching for "/usr/share/nvim/site/pack/*/start/*"
Searching for "/usr/share/nvim/runtime/pack/*/start/*"
Searching for "/usr/lib/nvim/pack/*/start/*"
Searching for "/usr/share/nvim/site/after/pack/*/start/*"
Searching for "/usr/local/share/nvim/site/after/pack/*/start/*"
Searching for "/home/burp/.local/share/nvim/site/after/pack/*/start/*"
Searching for "/etc/xdg/nvim/after/pack/*/start/*"
Searching for "/home/burp/.config/nvim/after/pack/*/start/*"
not found in 'packpath': "pack/*/start/*"
Searching for "start/*" in "/home/burp/.config/nvim,/etc/xdg/nvim,/home/burp/.local/share/nvim/site,/usr/local/share/nvim/site,/usr/share/nvim/site,/usr/share/nvim/runtime,/usr/lib/nvim,/usr/share/nvim/site/after,/usr/local/share/nvim/site/after,/home/burp/.local/share/nvim/site/after,/etc/xdg/nvim/after,/home/burp/.config/nvim/after"
Searching for "/home/burp/.config/nvim/start/*"
Searching for "/etc/xdg/nvim/start/*"
Searching for "/home/burp/.local/share/nvim/site/start/*"
Searching for "/usr/local/share/nvim/site/start/*"
Searching for "/usr/share/nvim/site/start/*"
Searching for "/usr/share/nvim/runtime/start/*"
Searching for "/usr/lib/nvim/start/*"
Searching for "/usr/share/nvim/site/after/start/*"
Searching for "/usr/local/share/nvim/site/after/start/*"
Searching for "/home/burp/.local/share/nvim/site/after/start/*"
Searching for "/etc/xdg/nvim/after/start/*"
Searching for "/home/burp/.config/nvim/after/start/*"
not found in 'packpath': "start/*"
Searching for "plugin/**/*.vim" in runtime path
not found in runtime path: "plugin/**/*.vim"
Searching for "plugin/**/*.lua" in runtime path
not found in runtime path: "plugin/**/*.lua"
Reading ShaDa file "/home/burp/.local/state/nvim/shada/main.shada" info marks oldfiles
Executing BufEnter Autocommands for "*"
autocommand sil call s:LocalBrowse(expand("<amatch>"))

Executing: sil call s:LocalBrowse(expand("<amatch>"))
calling <SNR>29_LocalBrowse('')

line 1:   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
line 2:   " Otherwise, the BufEnter event gets triggered when attempts to write to
line 3:   " the DBG buffer are made.
line 4: 
line 5:   if !exists("s:vimentered")
line 6:    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
line 7:    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
line 8: "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
line 9: "   call Dret("s:LocalBrowse")
line 10:    return
<SNR>29_LocalBrowse returning #0

continuing in BufEnter Autocommands for "*"

Executing VimEnter Autocommands for "*"
autocommand call youcompleteme#Enable()

Executing: call youcompleteme#Enable()
Searching for "autoload/youcompleteme.vim" in runtime path
Searching for "/home/burp/.config/nvim/autoload/youcompleteme.vim"
Searching for "/home/burp/.vim/bundle/Vundle.vim/autoload/youcompleteme.vim"
Searching for "/home/burp/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/.vim/bundle/YouCompleteMe/autoload)
chdir(/home/burp/Applications/.bash_aliases)
line 0: sourcing "/home/burp/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim"
line 1: " Copyright (C) 2011-2018 YouCompleteMe contributors
line 2: "
line 3: " This file is part of YouCompleteMe.
line 4: "
line 5: " YouCompleteMe is free software: you can redistribute it and/or modify
line 6: " it under the terms of the GNU General Public License as published by
line 7: " the Free Software Foundation, either version 3 of the License, or
line 8: " (at your option) any later version.
line 9: "
line 10: " YouCompleteMe is distributed in the hope that it will be useful,
line 11: " but WITHOUT ANY WARRANTY; without even the implied warranty of
line 12: " MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
line 13: " GNU General Public License for more details.
line 14: "
line 15: " You should have received a copy of the GNU General Public License
line 16: " along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.
line 17: 
line 18: " This is basic vim plugin boilerplate
line 19: let s:save_cpo = &cpo
line 20: set cpo&vim
line 21: 
line 22: " NOTE: Noevim reports v:version as 800, which is garbage. For some features
line 23: " that are supporetd by our minimum Vim version, we have to guard them against
line 24: " neovim, which doesn't implement them.
line 25: let s:is_neovim = has( 'nvim' )
line 26: 
line 27: " Only useful in neovim, for handling text properties... I mean extmarks.
line 28: let g:ycm_neovim_ns_id = s:is_neovim ? nvim_create_namespace( 'ycm_id' ) : -1
line 29: 
line 30: " This needs to be called outside of a function
line 31: let s:script_folder_path = escape( expand( '<sfile>:p:h' ), '\' )
line 32: let s:force_semantic = 0
line 33: let s:force_manual = 0
line 34: let s:completion_stopped = 0
line 35: " These two variables are initialized in youcompleteme#Enable.
line 36: let s:default_completion = {}
line 37: let s:completion = s:default_completion
line 38: let s:default_signature_help = {}
line 39: let s:signature_help = s:default_completion
line 40: let s:previous_allowed_buffer_number = 0
line 41: let s:pollers = {   'completion': {     'id': -1,     'wait_milliseconds': 10,   },   'signature_help': {     'id': -1,     'wait_milliseconds': 10,   },   'file_parse_response': {     'id': -1,     'wait_milliseconds': 100,   },   'server_ready': {     'id': -1,     'wait_milliseconds': 100,   },   'receive_messages': {     'id': -1,     'wait_milliseconds': 100,   },   'command': {     'id': -1,     'wait_milliseconds': 100,     'requests': {},   },   'semantic_highlighting': {     'id': -1,     'wait_milliseconds': 100,   },   'inlay_hints': {     'id': -1,     'wait_milliseconds': 100,   }, }
line 76: let s:buftype_blacklist = {   'help': 1,   'terminal': 1,   'quickfix': 1,   'popup': 1,   'nofile': 1, }
line 83: let s:last_char_inserted_by_user = v:true
line 84: let s:enable_hover = 0
line 85: let s:cursorhold_popup = -1
line 86: let s:enable_inlay_hints = 0
line 87: 
line 88: let s:force_preview_popup = 0
line 89: 
line 90: let s:RESOLVE_NONE = 0
line 91: let s:RESOLVE_UP_FRONT = 1
line 92: let s:RESOLVE_ON_DEMAND = 2
line 93: let s:resolve_completions = s:RESOLVE_NONE
line 94: 
line 95: function! s:StartMessagePoll()
line 102: 
line 103: 
line 104: function! s:ReceiveMessages( timer_id )
line 119: 
line 120: 
line 121: function! s:SetUpOptions()
line 134: 
line 135: 
line 136: function! youcompleteme#Enable()
line 233: 
line 234: 
line 235: function! youcompleteme#EnableCursorMovedAutocommands()
line 250: 
line 251: 
line 252: function! youcompleteme#DisableCursorMovedAutocommands()
line 255: 
line 256: 
line 257: function! youcompleteme#GetErrorCount()
line 260: 
line 261: 
line 262: function! youcompleteme#GetWarningCount()
line 265: 
line 266: 
line 267: function! s:SetUpPython() abort
line 326: 
line 327: 
line 328: function! s:SetUpKeyMappings()
line 381: 
line 382: 
line 383: function! s:SetUpSigns()
line 425: 
line 426: 
line 427: function! s:SetUpSyntaxHighlighting()
line 516: 
line 517: 
line 518: function! s:SetUpBackwardsCompatibility()
line 532: 
line 533: 
line 534: " Needed so that YCM is used instead of Syntastic
line 535: function! s:TurnOffSyntasticForCFamily()
line 542: 
line 543: 
line 544: function! s:DisableOnLargeFile( buffer )
line 558: 
line 559: function! s:PropertyTypeNotDefined( type )
line 563: 
line 564: function! s:AllowedToCompleteInBuffer( buffer )
line 585: 
line 586: 
line 587: function! s:AllowedToCompleteInCurrentBuffer()
line 590: 
line 591: 
line 592: function! s:VisitedBufferRequiresReparse()
line 599: 
line 600: 
line 601: function! s:SetUpCpoptions()
line 610: 
line 611: 
line 612: function! s:SetUpCompleteopt()
line 640: 
line 641: 
line 642: function! s:EnableCompletingInCurrentBuffer()
line 648: 
line 649: 
line 650: function s:StopPoller( poller ) abort
line 654: 
line 655: 
line 656: function! s:OnVimLeave()
line 664: 
line 665: 
line 666: function! s:OnCompleteDone()
line 676: 
line 677: 
line 678: function! s:OnCompleteChanged()
line 690: 
line 691: 
line 692: function! s:ResolveCompletionItem( item )
line 709: 
line 710: 
line 711: function! s:EnableAutoHover()
line 719: 
line 720: 
line 721: function! s:DisableAutoHover()
line 726: 
line 727: 
line 728: function! s:OnFileTypeSet()
line 748: 
line 749: 
line 750: function! s:OnFileSave()
line 757: 
line 758: 
line 759: function! s:OnBufferEnter()
line 774: 
line 775: 
line 776: function! s:OnBufferUnload()
line 786: 
line 787: 
line 788: function! s:PollServerReady( timer_id )
line 804: 
line 805: 
line 806: function! s:OnFileReadyToParse( ... )
line 830: 
line 831: function! s:UpdateSemanticHighlighting( bufnr ) abort
line 845: 
line 846: 
line 847: function s:ShouldUseInlayHintsNow( bufnr )
line 852: 
line 853: function! s:UpdateInlayHints( bufnr, force, redraw_anyway )
line 869: 
line 870: 
line 871: function! s:PollFileParseResponse( ... )
line 884: 
line 885: 
line 886: function! s:PollSemanticHighlighting( bufnr, ... )
line 901: 
line 902: 
line 903: function! s:PollInlayHints( bufnr, ... )
line 918: 
line 919: 
line 920: 
line 921: function! s:SendKeys( keys )
line 931: 
line 932: 
line 933: function! s:CloseCompletionMenu()
line 938: 
line 939: 
line 940: function! s:OnInsertChar()
line 947: 
line 948: 
line 949: function! s:StopCompletion( key )
line 960: 
line 961: 
line 962: function! s:OnCursorMovedNormalMode()
line 969: 
line 970: 
line 971: function! s:OnWinScrolled()
line 979: 
line 980: 
line 981: function! s:OnTextChangedNormalMode()
line 988: 
line 989: 
line 990: function! s:OnTextChangedInsertMode( popup_is_visible )
line 1034: 
line 1035: 
line 1036: function! s:OnInsertEnter() abort
line 1044: 
line 1045: function! s:OnInsertLeave()
line 1071: 
line 1072: 
line 1073: function! s:ClosePreviewWindowIfNeeded()
line 1087: 
line 1088: 
line 1089: function! s:IdentifierFinishedOperations()
line 1098: 
line 1099: 
line 1100: " Returns 1 when inside comment and 2 when inside string
line 1101: function! s:InsideCommentOrString()
line 1117: 
line 1118: 
line 1119: function! s:InsideCommentOrStringAndShouldStop()
line 1131: 
line 1132: 
line 1133: function! s:OnBlankLine()
line 1136: 
line 1137: 
line 1138: function! s:RequestCompletion()
line 1159: 
line 1160: function! s:ManuallyRequestCompletion() abort
line 1177: 
line 1178: function! s:SetCompleteFunc()
line 1181: 
line 1182: function! youcompleteme#CompleteFunc( findstart, base ) abort
line 1187: 
line 1188: inoremap <silent> <plug>(YCMComplete) <C-r>=<SID>ManuallyRequestCompletion()<CR>
line 1189: 
line 1190: function! s:RequestSemanticCompletion() abort
line 1221: 
line 1222: 
line 1223: function! s:PollCompletion( ... )
line 1236: 
line 1237: 
line 1238: function! s:PollResolve( item, ... )
line 1260: 
line 1261: function! s:ShowInfoPopup( completion_item )
line 1268: 
line 1269: 
line 1270: function! s:ShouldUseSignatureHelp()
line 1273: 
line 1274: 
line 1275: function! s:RequestSignatureHelp()
line 1286: 
line 1287: 
line 1288: function! s:PollSignatureHelp( ... )
line 1309: 
line 1310: function! s:Complete()
line 1341: 
line 1342: function! s:UpdateSignatureHelp()
line 1350: 
line 1351: 
line 1352: function! s:ClearSignatureHelp()
line 1361: 
line 1362: 
line 1363: function! youcompleteme#ServerPid()
line 1366: 
line 1367: 
line 1368: function! s:SetUpCommands()
line 1386: 
line 1387: 
line 1388: function! s:RestartServer()
line 1402: 
line 1403: 
line 1404: function! s:DebugInfo()
line 1415: 
line 1416: 
line 1417: function! s:ToggleLogs( count, ... )
line 1421: 
line 1422: 
line 1423: function! youcompleteme#LogsComplete( arglead, cmdline, cursorpos )
line 1426: 
line 1427: 
line 1428: function! youcompleteme#GetCommandResponse( ... ) abort
line 1439: 
line 1440: 
line 1441: function! youcompleteme#GetCommandResponseAsync( callback, ... ) abort
line 1464: 
line 1465: 
line 1466: function! youcompleteme#GetRawCommandResponseAsync( callback, ... ) abort
line 1489: 
line 1490: 
line 1491: function! s:PollCommands( timer_id ) abort
line 1529: 
line 1530: 
line 1531: function! s:CompleterCommand( mods, count, line1, line2, ... )
line 1539: 
line 1540: 
line 1541: function! youcompleteme#SubCommandsComplete( arglead, cmdline, cursorpos )
line 1544: 
line 1545: 
line 1546: function! youcompleteme#GetDefinedSubcommands()
line 1557: 
line 1558: 
line 1559: function! youcompleteme#OpenGoToList()
line 1565: 
line 1566: 
line 1567: function! s:ShowDiagnostics()
line 1570: 
line 1571: 
line 1572: function! s:ShowDetailedDiagnostic( ... )
line 1580: 
line 1581: 
line 1582: function! s:ForceCompileAndDiagnostics()
line 1585: 
line 1586: 
line 1587: if exists( '*popup_atcursor' )
line 1588:   function s:Hover()
line 1625: 
line 1626: 
line 1627:   function! s:ShowHoverResult( response )
line 1669: 
line 1670: 
line 1671:   function! s:ToggleHover()
line 1687: 
line 1688:   let s:enable_hover = 1
line 1689:   nnoremap <silent> <plug>(YCMHover) :<C-u>call <SID>ToggleHover()<CR>
line 1690: else
line 1691:   " Don't break people's mappings if this feature is disabled, just do nothing.
line 1692:   nnoremap <silent> <plug>(YCMHover) <Nop>
line 1693: endif
line 1694: 
line 1695: function! youcompleteme#Test_GetPollers()
line 1698: 
line 1699: function! s:ToggleSignatureHelp()
line 1705: 
line 1706: silent! inoremap <silent> <plug>(YCMToggleSignatureHelp) <C-r>=<SID>ToggleSignatureHelp()<CR>
line 1708: 
line 1709: function! s:ToggleInlayHints()
line 1721: 
line 1722: silent! nnoremap <silent> <plug>(YCMToggleInlayHints) <cmd>call <SID>ToggleInlayHints()<CR>
line 1724: 
line 1725: " This is basic vim plugin boilerplate
line 1726: let &cpo = s:save_cpo
line 1727: unlet s:save_cpo
finished sourcing /home/burp/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim
continuing in VimEnter Autocommands for "*"
calling youcompleteme#Enable()

line 1:   call s:SetUpBackwardsCompatibility()
calling <SNR>40_SetUpBackwardsCompatibility()

line 1:   let complete_in_comments_and_strings = get( g:, 'ycm_complete_in_comments_and_strings', 0 )
line 3: 
line 4:   if complete_in_comments_and_strings
line 5:     let g:ycm_complete_in_strings = 1
line 6:     let g:ycm_complete_in_comments = 1
line 7:   endif
line 8: 
line 9:   " ycm_filetypes_to_completely_ignore is the old name for fileype_blacklist
line 10:   if has_key( g:, 'ycm_filetypes_to_completely_ignore' )
line 11:     let g:filetype_blacklist =  g:ycm_filetypes_to_completely_ignore
line 12:   endif
<SNR>40_SetUpBackwardsCompatibility returning #0

continuing in youcompleteme#Enable

line 2: 
line 3:   let completeopt = split( &completeopt, ',' )
line 4: 
line 5:   " Will we add 'popup' to the 'completeopt' (later)
line 6:   let s:force_preview_popup = type( g:ycm_add_preview_to_completeopt ) == v:t_string && g:ycm_add_preview_to_completeopt ==# 'popup' && !s:is_neovim
line 10: 
line 11:   " Will we add 'preview' to the 'completeopt' (later)
line 12:   let force_preview = type( g:ycm_add_preview_to_completeopt ) != v:t_string && g:ycm_add_preview_to_completeopt
line 15: 
line 16:   " Will we be using the preview popup ? That is either the user set it in their
line 17:   " compelteopt or we're going to add it later.
line 18:   let use_preview_popup = s:force_preview_popup || index( completeopt, 'popup' ) >= 0
line 21: 
line 22:   " We should only ask the server to resolve completion items upfront if we're
line 23:   " going to display them - that is either:
line 24:   "  - popup is (or will be) in completeopt
line 25:   "  - preview is (or will be) in completeopt, or
line 26:   let require_resolve = use_preview_popup || force_preview || index( completeopt, 'preview' ) >= 0
line 30: 
line 31:   if use_preview_popup && exists( '*popup_findinfo' )
line 32:     " If the preview popup is going to be used, and on-demand resolve can be
line 33:     " supported, enable it.
line 34:     let s:resolve_completions = s:RESOLVE_ON_DEMAND
line 35:   elseif require_resolve
line 36:     " The preview window or info popup is enalbed - request the server
line 37:     " pre-resolves completion items
line 38:     let s:resolve_completions = s:RESOLVE_UP_FRONT
line 39:   else
line 40:     " Otherwise, there's no point in resolving completions - they'll never be
line 41:     " displayed.
line 42:   endif
line 43: 
line 44:   if !s:SetUpPython()
calling <SNR>40_SetUpPython()

line 1:   py3 << EOF
calling provider#python3#Call('execute', ['import os.path as p
import sys
imp...  vim.command( ''return 1'' )
', 1, 1])

line 1:   if s:err != ''
line 2:     return
line 3:   endif
line 4:   if !exists('s:host')
line 5:     let s:rpcrequest = function('rpcrequest')
line 6: 
line 7:     " Ensure that we can load the Python3 host before bootstrapping
line 8:     try
line 9:       let s:host = remote#host#Require('legacy-python3-provider')
calling remote#host#Require('legacy-python3-provider')

line 1:   if !has_key(s:hosts, a:name)
line 2:     throw 'No host named "'.a:name.'" is registered'
line 3:   endif
line 4:   let host = s:hosts[a:name]
line 5:   if !host.channel && !host.initialized
line 6:     let host_info = { 'name': a:name, 'orig_name': get(host, 'orig_name', a:name) }
line 10:     let host.channel = call(host.factory, [host_info])
calling provider#pythonx#Require({'orig_name': 'python3', 'name': 'legacy-python3-provider'})

line 1:   " Python host arguments
line 2:   let prog = provider#python3#Prog()
calling provider#python3#Prog()

line 1:   return s:prog
provider#python3#Prog returning '/usr/bin/python3'

continuing in provider#pythonx#Require

line 3:   let args = [prog, '-c', 'import sys; sys.path = [p for p in sys.path if p != ""]; import neovim; neovim.start_host()']
line 4: 
line 5: 
line 6:   " Collect registered Python plugins into args
line 7:   let python_plugins = remote#host#PluginsForHost(a:host.name)
calling remote#host#PluginsForHost('legacy-python3-provider')

line 1:   if !has_key(s:plugins_for_host, a:host)
line 2:     let s:plugins_for_host[a:host] = []
line 3:   end
line 4:   return s:plugins_for_host[a:host]
remote#host#PluginsForHost returning [{'specs': [], 'path': 'script_host.py'}]

continuing in provider#pythonx#Require

line 8:   for plugin in python_plugins
line 9:     call add(args, plugin.path)
line 10:   endfor
line 8:   for plugin in python_plugins
line 9:     call add(args, plugin.path)
line 10:   endfor
line 11: 
line 12:   return provider#Poll(args, a:host.orig_name, '$NVIM_PYTHON_LOG_FILE', {'overlapped': v:true})
Searching for "autoload/provider.vim" in runtime path
Searching for "/home/burp/.config/nvim/autoload/provider.vim"
Searching for "/home/burp/.vim/bundle/Vundle.vim/autoload/provider.vim"
Searching for "/home/burp/.vim/bundle/YouCompleteMe/autoload/provider.vim"
Searching for "/home/burp/.vim/bundle/vim-fugitive/autoload/provider.vim"
Searching for "/home/burp/.vim/bundle/vim-tmux-navigator/autoload/provider.vim"
Searching for "/etc/xdg/nvim/autoload/provider.vim"
Searching for "/usr/share/nvim/runtime/autoload/provider.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/autoload)
chdir(/home/burp/Applications/.bash_aliases)
line 12: sourcing "/usr/share/nvim/runtime/autoload/provider.vim"
line 1: " Common functions for providers
line 2: 
line 3: " Start the provider and perform a 'poll' request
line 4: "
line 5: " Returns a valid channel on success
line 6: function! provider#Poll(argv, orig_name, log_env, ...) abort
finished sourcing /usr/share/nvim/runtime/autoload/provider.vim
continuing in provider#pythonx#Require
calling provider#Poll(['/usr/bin/python3', '-c', 'import sys...neovim.start_host()', 'script_host.py'], 'python3', '$NVIM_PYTHON_LOG_FILE', {'overlapped': v:true})

line 1:   let job = {'rpc': v:true, 'stderr_buffered': v:true}
line 2:   if a:0
line 3:     let job = extend(job, a:1)
line 4:   endif
line 5:   try
line 6:     let channel_id = jobstart(a:argv, job)
line 7:     if channel_id > 0 && rpcrequest(channel_id, 'poll') ==# 'ok'
line 8:       return channel_id
:return 3 made pending

line 9:     endif
line 10:   catch
line 11:     echomsg v:throwpoint
line 12:     echomsg v:exception
line 13:     for row in get(job, 'stderr', [])
line 14:       echomsg row
line 15:     endfor
line 16:   endtry
:return 3 resumed

provider#Poll returning #3

continuing in provider#pythonx#Require

provider#pythonx#Require returning #3

continuing in remote#host#Require

line 11:     let host.initialized = 1
line 12:   endif
line 13:   return host.channel
remote#host#Require returning #3

continuing in provider#python3#Call

line 10:     catch
line 11:       let s:err = v:exception
line 12:       echohl WarningMsg
line 13:       echomsg v:exception
line 14:       echohl None
line 15:       return
line 16:     endtry
line 17:   endif
line 18:   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))
line 57: au DirChanged * call rpcnotify(3, "python_chdir", v:event.cwd)
line 57: call rpcnotify(3, "python_chdir", getcwd())
line 57: return 1
provider#python3#Call returning v:null

continuing in <SNR>40_SetUpPython

<SNR>40_SetUpPython returning #1

continuing in youcompleteme#Enable

line 45:     return
line 46:   endif
line 47: 
line 48:   call s:SetUpOptions()
calling <SNR>40_SetUpOptions()

line 1:   call s:SetUpCommands()
calling <SNR>40_SetUpCommands()

line 1:   command! YcmRestartServer call s:RestartServer()
line 2:   command! YcmDebugInfo call s:DebugInfo()
line 3:   command! -nargs=* -complete=custom,youcompleteme#LogsComplete -count=0 YcmToggleLogs call s:ToggleLogs( <f-count>, <f-mods>, <f-args>)
line 7:   command! -nargs=* -complete=custom,youcompleteme#SubCommandsComplete -range YcmCompleter call s:CompleterCommand(<q-mods>,                                      <count>,                                      <line1>,                                      <line2>,                                      <f-args>)
line 13:   command! YcmDiags call s:ShowDiagnostics()
line 14:   command! -nargs=? YcmShowDetailedDiagnostic call s:ShowDetailedDiagnostic( <f-args> )
line 16:   command! YcmForceCompileAndDiagnostics call s:ForceCompileAndDiagnostics()
<SNR>40_SetUpCommands returning #0

continuing in <SNR>40_SetUpOptions

line 2:   call s:SetUpCpoptions()
calling <SNR>40_SetUpCpoptions()

line 1:   " Without this flag in cpoptions, critical YCM mappings do not work. There's
line 2:   " no way to not have this and have YCM working, so force the flag.
line 3:   set cpoptions+=B
line 4: 
line 5:   " This prevents the display of "Pattern not found" & similar messages during
line 6:   " completion.
line 7:   set shortmess+=c
<SNR>40_SetUpCpoptions returning #0

continuing in <SNR>40_SetUpOptions

line 3:   call s:SetUpCompleteopt()
calling <SNR>40_SetUpCompleteopt()

line 1:   " Some plugins (I'm looking at you, vim-notes) change completeopt by for
line 2:   " instance adding 'longest'. This breaks YCM. So we force our settings.
line 3:   " There's no two ways about this: if you want to use YCM then you have to
line 4:   " have these completeopt settings, otherwise YCM won't work at all.
line 5: 
line 6:   " We need menuone in completeopt, otherwise when there's only one candidate
line 7:   " for completion, the menu doesn't show up.
line 8:   set completeopt-=menu
line 9:   set completeopt+=menuone
line 10: 
line 11:   " This is unnecessary with our features. People use this option to insert
line 12:   " the common prefix of all the matches and then add more differentiating chars
line 13:   " so that they can select a more specific match. With our features, they
line 14:   " don't need to insert the prefix; they just type the differentiating chars.
line 15:   " Also, having this option set breaks the plugin.
line 16:   set completeopt-=longest
line 17: 
line 18:   if s:resolve_completions == s:RESOLVE_ON_DEMAND
line 19:     set completeopt+=popuphidden
line 20:   endif
line 21: 
line 22:   if s:force_preview_popup
line 23:     set completeopt+=popup
line 24:   elseif g:ycm_add_preview_to_completeopt
line 25:     set completeopt+=preview
line 26:   endif
<SNR>40_SetUpCompleteopt returning #0

continuing in <SNR>40_SetUpOptions

line 4:   call s:SetUpKeyMappings()
calling <SNR>40_SetUpKeyMappings()

line 1:   " The g:ycm_key_select_completion and g:ycm_key_previous_completion used to
line 2:   " exist and are now here purely for the sake of backwards compatibility; we
line 3:   " don't want to break users if we can avoid it.
line 4: 
line 5:   if exists('g:ycm_key_select_completion') && index(g:ycm_key_list_select_completion,       g:ycm_key_select_completion) == -1
line 8:     call add(g:ycm_key_list_select_completion, g:ycm_key_select_completion)
line 9:   endif
line 10: 
line 11:   if exists('g:ycm_key_previous_completion') && index(g:ycm_key_list_previous_completion,       g:ycm_key_previous_completion) == -1
line 14:     call add(g:ycm_key_list_previous_completion, g:ycm_key_previous_completion)
line 15:   endif
line 16: 
line 17:   for key in g:ycm_key_list_select_completion
line 18:     " With this command, when the completion window is visible, the tab key
line 19:     " (default) will select the next candidate in the window. In vim, this also
line 20:     " changes the typed-in text to that of the candidate completion.
line 21:     exe 'inoremap <expr>' . key .  ' pumvisible() ? "\<C-n>" : "\' . key .'"'
line 21: inoremap <expr><TAB> pumvisible() ? "\<C-n>" : "\<TAB>"
line 22:   endfor
line 17:   for key in g:ycm_key_list_select_completion
line 18:     " With this command, when the completion window is visible, the tab key
line 19:     " (default) will select the next candidate in the window. In vim, this also
line 20:     " changes the typed-in text to that of the candidate completion.
line 21:     exe 'inoremap <expr>' . key .  ' pumvisible() ? "\<C-n>" : "\' . key .'"'
line 21: inoremap <expr><Down> pumvisible() ? "\<C-n>" : "\<Down>"
line 22:   endfor
line 17:   for key in g:ycm_key_list_select_completion
line 18:     " With this command, when the completion window is visible, the tab key
line 19:     " (default) will select the next candidate in the window. In vim, this also
line 20:     " changes the typed-in text to that of the candidate completion.
line 21:     exe 'inoremap <expr>' . key .  ' pumvisible() ? "\<C-n>" : "\' . key .'"'
line 22:   endfor
line 23: 
line 24:   for key in g:ycm_key_list_previous_completion
line 25:     " This selects the previous candidate for shift-tab (default)
line 26:     exe 'inoremap <expr>' . key . ' pumvisible() ? "\<C-p>" : "\' . key .'"'
line 26: inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<S-TAB>"
line 27:   endfor
line 24:   for key in g:ycm_key_list_previous_completion
line 25:     " This selects the previous candidate for shift-tab (default)
line 26:     exe 'inoremap <expr>' . key . ' pumvisible() ? "\<C-p>" : "\' . key .'"'
line 26: inoremap <expr><Up> pumvisible() ? "\<C-p>" : "\<Up>"
line 27:   endfor
line 24:   for key in g:ycm_key_list_previous_completion
line 25:     " This selects the previous candidate for shift-tab (default)
line 26:     exe 'inoremap <expr>' . key . ' pumvisible() ? "\<C-p>" : "\' . key .'"'
line 27:   endfor
line 28: 
line 29:   for key in g:ycm_key_list_stop_completion
line 30:     " When selecting a candidate and closing the completion menu with the <C-y>
line 31:     " key, the menu will automatically be reopened because of the TextChangedI
line 32:     " event. We define a command to prevent that.
line 33:     exe 'inoremap <expr>' . key . ' <SID>StopCompletion( "\' . key . '" )'
line 33: inoremap <expr><C-y> <SID>StopCompletion( "\<C-y>" )
line 34:   endfor
line 29:   for key in g:ycm_key_list_stop_completion
line 30:     " When selecting a candidate and closing the completion menu with the <C-y>
line 31:     " key, the menu will automatically be reopened because of the TextChangedI
line 32:     " event. We define a command to prevent that.
line 33:     exe 'inoremap <expr>' . key . ' <SID>StopCompletion( "\' . key . '" )'
line 34:   endfor
line 35: 
line 36:   if !empty( g:ycm_key_invoke_completion )
line 37:     let invoke_key = g:ycm_key_invoke_completion
line 38: 
line 39:     " Inside the console, <C-Space> is passed as <Nul> to Vim
line 40:     if invoke_key ==# '<C-Space>'
line 41:       imap <Nul> <C-Space>
line 42:     endif
line 43: 
line 44:     silent! exe 'inoremap <unique> <silent> ' . invoke_key . ' <C-R>=<SID>RequestSemanticCompletion()<CR>'
line 44: inoremap <unique> <silent> <C-Space> <C-R>=<SID>RequestSemanticCompletion()<CR>
line 46:   endif
line 47: 
line 48:   if !empty( g:ycm_key_detailed_diagnostics )
line 49:     silent! exe 'nnoremap <unique> ' . g:ycm_key_detailed_diagnostics . ' :YcmShowDetailedDiagnostic<CR>'
line 49: nnoremap <unique> <leader>d :YcmShowDetailedDiagnostic<CR>
line 51:   endif
<SNR>40_SetUpKeyMappings returning #0

continuing in <SNR>40_SetUpOptions

line 5: 
line 6:   if g:ycm_show_diagnostics_ui
line 7:     call s:TurnOffSyntasticForCFamily()
calling <SNR>40_TurnOffSyntasticForCFamily()

line 1:   let g:syntastic_cpp_checkers = []
line 2:   let g:syntastic_c_checkers = []
line 3:   let g:syntastic_objc_checkers = []
line 4:   let g:syntastic_objcpp_checkers = []
line 5:   let g:syntastic_cuda_checkers = []
<SNR>40_TurnOffSyntasticForCFamily returning #0

continuing in <SNR>40_SetUpOptions

line 8:   endif
line 9: 
line 10:   call s:SetUpSigns()
calling <SNR>40_SetUpSigns()

line 1:   " We try to ensure backwards compatibility with Syntastic if the user has
line 2:   " already defined styling for Syntastic highlight groups.
line 3: 
line 4:   if !hlexists( 'YcmErrorSign' )
line 5:     if hlexists( 'SyntasticErrorSign')
line 6:       highlight default link YcmErrorSign SyntasticErrorSign
line 7:     else
line 8:       highlight default link YcmErrorSign error
line 9:     endif
line 10:   endif
line 11: 
line 12:   if !hlexists( 'YcmWarningSign' )
line 13:     if hlexists( 'SyntasticWarningSign')
line 14:       highlight default link YcmWarningSign SyntasticWarningSign
line 15:     else
line 16:       highlight default link YcmWarningSign todo
line 17:     endif
line 18:   endif
line 19: 
line 20:   if !hlexists( 'YcmErrorLine' )
line 21:     highlight default link YcmErrorLine SyntasticErrorLine
line 22:   endif
line 23: 
line 24:   if !hlexists( 'YcmWarningLine' )
line 25:     highlight default link YcmWarningLine SyntasticWarningLine
line 26:   endif
line 27: 
line 28:   call sign_define( [ { 'name': 'YcmError',   'text': g:ycm_error_symbol,   'texthl': 'YcmErrorSign',   'linehl': 'YcmErrorLine',   'group':  'ycm_signs' }, { 'name': 'YcmWarning',   'text': g:ycm_warning_symbol,   'texthl': 'YcmWarningSign',   'linehl': 'YcmWarningLine',   'group':  'ycm_signs' } ] )
line 40: 
<SNR>40_SetUpSigns returning #0

continuing in <SNR>40_SetUpOptions

line 11:   call s:SetUpSyntaxHighlighting()
calling <SNR>40_SetUpSyntaxHighlighting()

line 1:   " We try to ensure backwards compatibility with Syntastic if the user has
line 2:   " already defined styling for Syntastic highlight groups.
line 3: 
line 4:   if !hlexists( 'YcmErrorSection' )
line 5:     if hlexists( 'SyntasticError' )
line 6:       highlight default link YcmErrorSection SyntasticError
line 7:     else
line 8:       highlight default link YcmErrorSection SpellBad
line 9:     endif
line 10:   endif
line 11:   if s:PropertyTypeNotDefined( 'YcmErrorProperty' )
calling <SNR>40_PropertyTypeNotDefined('YcmErrorProperty')

line 1:   return exists( '*prop_type_add' ) && index( prop_type_list(), a:type ) == -1
<SNR>40_PropertyTypeNotDefined returning #0

continuing in <SNR>40_SetUpSyntaxHighlighting

line 12:     call prop_type_add( 'YcmErrorProperty', { 'highlight': 'YcmErrorSection', 'priority': 30, 'combine': 0, 'override': 1 } )
line 17:   endif
line 18: 
line 19:   " Used for virtual text
line 20:   if !hlexists( 'YcmInvisible' )
line 21:     highlight default link YcmInvisible Normal
line 22:   endif
line 23:   if !hlexists( 'YcmInlayHint' )
line 24:     highlight default link YcmInlayHint NonText
line 25:   endif
line 26:   if !hlexists( 'YcmErrorText' )
line 27:     if exists( '*hlget' )
line 28:       let YcmErrorText = hlget( 'SpellBad', v:true )[ 0 ]
line 29:       let YcmErrorText.name = 'YcmErrorText'
line 30:       let YcmErrorText.cterm = {}
line 31:       let YcmErrorText.gui = {}
line 32:       let YcmErrorText.term = {}
line 33:       call hlset( [ YcmErrorText ] )
line 34:     else
line 35:       " approximation
line 36:       hi default link YcmErrorText WarningMsg
line 37:     endif
line 38:   endif
line 39:   if !hlexists( 'YcmWarningText' )
line 40:     if exists( '*hlget' )
line 41:       let YcmWarningText = hlget( 'SpellCap', v:true )[ 0 ]
line 42:       let YcmWarningText.name = 'YcmWarningText'
line 43:       let YcmWarningText.cterm = {}
line 44:       let YcmWarningText.gui = {}
line 45:       let YcmWarningText.term = {}
line 46:       call hlset( [ YcmWarningText] )
line 47:     else
line 48:       " Lame approximation
line 49:       hi default link YcmWarningText Conceal
line 50:     endif
line 51:   endif
line 52: 
line 53:   if s:PropertyTypeNotDefined( 'YcmVirtDiagError' )
calling <SNR>40_PropertyTypeNotDefined('YcmVirtDiagError')

line 1:   return exists( '*prop_type_add' ) && index( prop_type_list(), a:type ) == -1
<SNR>40_PropertyTypeNotDefined returning #0

continuing in <SNR>40_SetUpSyntaxHighlighting

line 54:     call prop_type_add( 'YcmVirtDiagError', { 'highlight': 'YcmErrorText', 'priority': 20, 'combine': 0 } )
line 58:   endif
line 59:   if s:PropertyTypeNotDefined( 'YcmVirtDiagWarning' )
calling <SNR>40_PropertyTypeNotDefined('YcmVirtDiagWarning')

line 1:   return exists( '*prop_type_add' ) && index( prop_type_list(), a:type ) == -1
<SNR>40_PropertyTypeNotDefined returning #0

continuing in <SNR>40_SetUpSyntaxHighlighting

line 60:     call prop_type_add( 'YcmVirtDiagWarning', { 'highlight': 'YcmWarningText', 'priority': 19, 'combine': 0 } )
line 64:   endif
line 65: 
line 66: 
line 67:   if s:PropertyTypeNotDefined( 'YcmVirtDiagPadding' )
calling <SNR>40_PropertyTypeNotDefined('YcmVirtDiagPadding')

line 1:   return exists( '*prop_type_add' ) && index( prop_type_list(), a:type ) == -1
<SNR>40_PropertyTypeNotDefined returning #0

continuing in <SNR>40_SetUpSyntaxHighlighting

line 68:     call prop_type_add( 'YcmVirtDiagPadding', { 'highlight': 'YcmInvisible', 'priority': 100, 'combine': 1 } )
line 72:   endif
line 73: 
line 74:   if !hlexists( 'YcmWarningSection' )
line 75:     if hlexists( 'SyntasticWarning' )
line 76:       highlight default link YcmWarningSection SyntasticWarning
line 77:     else
line 78:       highlight default link YcmWarningSection SpellCap
line 79:     endif
line 80:   endif
line 81:   if s:PropertyTypeNotDefined( 'YcmWarningProperty' )
calling <SNR>40_PropertyTypeNotDefined('YcmWarningProperty')

line 1:   return exists( '*prop_type_add' ) && index( prop_type_list(), a:type ) == -1
<SNR>40_PropertyTypeNotDefined returning #0

continuing in <SNR>40_SetUpSyntaxHighlighting

line 82:     call prop_type_add( 'YcmWarningProperty', { 'highlight': 'YcmWarningSection', 'priority': 29, 'combine': 0, 'override': 1 } )
line 87:   endif
<SNR>40_SetUpSyntaxHighlighting returning #0

continuing in <SNR>40_SetUpOptions

<SNR>40_SetUpOptions returning #0

continuing in youcompleteme#Enable

line 49: 
line 50:   py3 ycm_semantic_highlighting.Initialise()
calling provider#python3#Call('execute', ['ycm_semantic_highlighting.Initialise()', 1, 1])

line 1:   if s:err != ''
line 2:     return
line 3:   endif
line 4:   if !exists('s:host')
line 5:     let s:rpcrequest = function('rpcrequest')
line 6: 
line 7:     " Ensure that we can load the Python3 host before bootstrapping
line 8:     try
line 9:       let s:host = remote#host#Require('legacy-python3-provider')
line 10:     catch
line 11:       let s:err = v:exception
line 12:       echohl WarningMsg
line 13:       echomsg v:exception
line 14:       echohl None
line 15:       return
line 16:     endtry
line 17:   endif
line 18:   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))
provider#python3#Call returning v:null

continuing in youcompleteme#Enable

line 51:   let s:enable_inlay_hints = py3eval( 'ycm_inlay_hints.Initialise()' ) ? 1 : 0
calling provider#python3#Call('eval', ['ycm_inlay_hints.Initialise()'])

line 1:   if s:err != ''
line 2:     return
line 3:   endif
line 4:   if !exists('s:host')
line 5:     let s:rpcrequest = function('rpcrequest')
line 6: 
line 7:     " Ensure that we can load the Python3 host before bootstrapping
line 8:     try
line 9:       let s:host = remote#host#Require('legacy-python3-provider')
line 10:     catch
line 11:       let s:err = v:exception
line 12:       echohl WarningMsg
line 13:       echomsg v:exception
line 14:       echohl None
line 15:       return
line 16:     endtry
line 17:   endif
line 18:   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))
provider#python3#Call returning v:false

continuing in youcompleteme#Enable

line 52: 
line 53:   call youcompleteme#EnableCursorMovedAutocommands()
calling youcompleteme#EnableCursorMovedAutocommands()

line 1:   augroup ycmcompletemecursormove
line 2:     autocmd!
line 3:     autocmd CursorMoved * call s:OnCursorMovedNormalMode()
line 4:     autocmd CursorMovedI * let s:current_cursor_position = getpos( '.' )
line 5:     autocmd InsertEnter * call s:OnInsertEnter()
line 6:     autocmd TextChanged * call s:OnTextChangedNormalMode()
line 7:     autocmd TextChangedI * call s:OnTextChangedInsertMode( v:false )
line 8:     autocmd TextChangedP * call s:OnTextChangedInsertMode( v:true )
line 9:     autocmd InsertCharPre * call s:OnInsertChar()
line 10:     if exists( '##WinScrolled' )
line 11:       autocmd WinScrolled * call s:OnWinScrolled()
line 12:     endif
line 13:   augroup END
youcompleteme#EnableCursorMovedAutocommands returning #0

continuing in youcompleteme#Enable

line 54:   augroup youcompleteme
line 55:     autocmd!
line 56:     " Note that these events will NOT trigger for the file vim is started with;
line 57:     " so if you do "vim foo.cc", these events will not trigger when that buffer
line 58:     " is read. This is because youcompleteme#Enable() is called on VimEnter and
line 59:     " that happens *after* FileType has already triggered for the initial file.
line 60:     " We don't parse the buffer on the BufRead event since it would only be
line 61:     " useful if the buffer filetype is set (we ignore the buffer if there is no
line 62:     " filetype) and if so, the FileType event has triggered before and thus the
line 63:     " buffer is already parsed.
line 64:     autocmd BufWritePost,FileWritePost * call s:OnFileSave()
line 65:     autocmd FileType * call s:OnFileTypeSet()
line 66:     autocmd BufEnter,CmdwinEnter,WinEnter * call s:OnBufferEnter()
line 67:     autocmd BufUnload * call s:OnBufferUnload()
line 68:     autocmd InsertLeave * call s:OnInsertLeave()
line 69:     autocmd VimLeave * call s:OnVimLeave()
line 70:     autocmd CompleteDone * call s:OnCompleteDone()
line 71:     autocmd CompleteChanged * call s:OnCompleteChanged()
line 72:   augroup END
line 73: 
line 74:   " The FileType event is not triggered for the first loaded file. We wait until
line 75:   " the server is ready to manually run the s:OnFileTypeSet function.
line 76:   let s:pollers.server_ready.id = timer_start( s:pollers.server_ready.wait_milliseconds, function( 's:PollServerReady' ) )
line 79: 
line 80:   let s:default_completion = py3eval( 'vimsupport.NO_COMPLETIONS' )
calling provider#python3#Call('eval', ['vimsupport.NO_COMPLETIONS'])

line 1:   if s:err != ''
line 2:     return
line 3:   endif
line 4:   if !exists('s:host')
line 5:     let s:rpcrequest = function('rpcrequest')
line 6: 
line 7:     " Ensure that we can load the Python3 host before bootstrapping
line 8:     try
line 9:       let s:host = remote#host#Require('legacy-python3-provider')
line 10:     catch
line 11:       let s:err = v:exception
line 12:       echohl WarningMsg
line 13:       echomsg v:exception
line 14:       echohl None
line 15:       return
line 16:     endtry
line 17:   endif
line 18:   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))
provider#python3#Call returning {'completion_start_column': -1, 'completions': [], 'column': -1, 'line': -1}

continuing in youcompleteme#Enable

line 81:   let s:completion = s:default_completion
line 82: 
line 83:   if s:PropertyTypeNotDefined( 'YCM-signature-help-current-argument' )
calling <SNR>40_PropertyTypeNotDefined('YCM-signature-help-current-argument')

line 1:   return exists( '*prop_type_add' ) && index( prop_type_list(), a:type ) == -1
<SNR>40_PropertyTypeNotDefined returning #0

continuing in youcompleteme#Enable

line 84:     hi default YCMInverse term=reverse cterm=reverse gui=reverse
line 85:     call prop_type_add( 'YCM-signature-help-current-argument', {   'highlight': 'YCMInverse',   'combine':   1,   'priority':  50, } )
line 90:   endif
line 91: 
line 92:   nnoremap <silent> <plug>(YCMFindSymbolInWorkspace) :call youcompleteme#finder#FindSymbol( 'workspace' )<CR>
line 94:   nnoremap <silent> <plug>(YCMFindSymbolInDocument) :call youcompleteme#finder#FindSymbol( 'document' )<CR>
youcompleteme#Enable returning #0

continuing in VimEnter Autocommands for "*"

Executing VimEnter Autocommands for "*"
autocommand sil call s:VimEnter(expand("<amatch>"))

Executing: sil call s:VimEnter(expand("<amatch>"))
calling <SNR>29_VimEnter('')

line 1: "  call Dfunc("s:VimEnter(dirname<".a:dirname.">) expand(%)<".expand("%").">")
line 2:   if has('nvim') || v:version < 802
line 3:   " Johann Höchtl: reported that the call range... line causes an E488: Trailing characters
line 4:   "                error with neovim. I suspect its because neovim hasn't updated with recent
line 5:   "                vim patches. As is, this code will have problems with popup terminals
line 6:   "                instantiated before the VimEnter event runs.
line 7:   " Ingo Karkat  : E488 also in Vim 8.1.1602
line 8:   let curwin       = winnr()
line 9:   let s:vimentered = 1
line 10:   windo call s:LocalBrowse(expand("%:p"))
line 10: call s:LocalBrowse(expand("%:p"))
calling <SNR>29_LocalBrowse('')

line 1:   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
line 2:   " Otherwise, the BufEnter event gets triggered when attempts to write to
line 3:   " the DBG buffer are made.
line 4: 
line 5:   if !exists("s:vimentered")
line 6:    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
line 7:    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
line 8: "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
line 9: "   call Dret("s:LocalBrowse")
line 10:    return
line 11:   endif
line 12: 
line 13: "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
line 14: 
line 15:   if has("amiga")
line 16:    " The check against '' is made for the Amiga, where the empty
line 17:    " string is the current directory and not checking would break
line 18:    " things such as the help command.
line 19: "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
line 20:    if a:dirname != '' && isdirectory(a:dirname)
line 21:     sil! call netrw#LocalBrowseCheck(a:dirname)
line 22:     if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
line 23:      exe w:netrw_bannercnt
line 24:     endif
line 25:    endif
line 26: 
line 27:   elseif isdirectory(a:dirname)
line 28: "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
line 29: "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
line 30:    " Jul 13, 2021: for whatever reason, preceding the following call with
line 31:    " a   sil!  causes an unbalanced if-endif vim error
line 32:    call netrw#LocalBrowseCheck(a:dirname)
line 33:    if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
line 34:     exe w:netrw_bannercnt
line 35:    endif
line 36: 
line 37:   else
line 38:    " not a directory, ignore it
line 39: "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
line 40:   endif
line 41: 
line 42: "  call Dret("s:LocalBrowse")
<SNR>29_LocalBrowse returning #0

continuing in <SNR>29_VimEnter

line 11:   exe curwin."wincmd w"
line 11: 1wincmd w
line 12:  else
line 13:   " the following complicated expression comes courtesy of lacygoill; largely does the same thing as the windo and 
line 14:   " wincmd which are commented out, but avoids some side effects. Allows popup terminal before VimEnter.
line 15:   let s:vimentered = 1
line 16:   call range(1, winnr('$'))->map({_, v -> win_execute(win_getid(v), 'call expand("%:p")->s:LocalBrowse()')})
line 17:  endif
line 18: "  call Dret("s:VimEnter")
<SNR>29_VimEnter returning #0

continuing in VimEnter Autocommands for "*"

Searching for "autoload/provider/clipboard.vim" in runtime path
Searching for "/home/burp/.config/nvim/autoload/provider/clipboard.vim"
Searching for "/home/burp/.vim/bundle/Vundle.vim/autoload/provider/clipboard.vim"
Searching for "/home/burp/.vim/bundle/YouCompleteMe/autoload/provider/clipboard.vim"
Searching for "/home/burp/.vim/bundle/vim-fugitive/autoload/provider/clipboard.vim"
Searching for "/home/burp/.vim/bundle/vim-tmux-navigator/autoload/provider/clipboard.vim"
Searching for "/etc/xdg/nvim/autoload/provider/clipboard.vim"
Searching for "/usr/share/nvim/runtime/autoload/provider/clipboard.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/usr/share/nvim/runtime/autoload/provider)
chdir(/home/burp/Applications/.bash_aliases)
sourcing "/usr/share/nvim/runtime/autoload/provider/clipboard.vim"
line 1: " The clipboard provider uses shell commands to communicate with the clipboard.
line 2: " The provider function will only be registered if a supported command is
line 3: " available.
line 4: 
line 5: if exists('g:loaded_clipboard_provider')
line 6:   finish
line 7: endif
line 8: " Default to 1.  provider#clipboard#Executable() may set 2.
line 9: " To force a reload:
line 10: "   :unlet g:loaded_clipboard_provider
line 11: "   :runtime autoload/provider/clipboard.vim
line 12: let g:loaded_clipboard_provider = 1
line 13: 
line 14: let s:copy = {}
line 15: let s:paste = {}
line 16: let s:clipboard = {}
line 17: 
line 18: " When caching is enabled, store the jobid of the xclip/xsel process keeping
line 19: " ownership of the selection, so we know how long the cache is valid.
line 20: let s:selection = { 'owner': 0, 'data': [], 'stderr_buffered': v:true }
line 21: 
line 22: function! s:selection.on_exit(jobid, data, event) abort
line 34: 
line 35: let s:selections = { '*': s:selection, '+': copy(s:selection) }
line 36: 
line 37: function! s:try_cmd(cmd, ...) abort
line 50: 
line 51: " Returns TRUE if `cmd` exits with success, else FALSE.
line 52: function! s:cmd_ok(cmd) abort
line 56: 
line 57: function! s:split_cmd(cmd) abort
line 60: 
line 61: let s:cache_enabled = 1
line 62: let s:err = ''
line 63: 
line 64: function! provider#clipboard#Error() abort
line 67: 
line 68: function! provider#clipboard#Executable() abort
line 152: 
line 153: function! s:clipboard.get(reg) abort
line 170: 
line 171: function! s:clipboard.set(lines, regtype, reg) abort
line 229: 
line 230: function! provider#clipboard#Call(method, args) abort
line 241: 
line 242: " eval_has_provider() decides based on this variable.
line 243: let g:loaded_clipboard_provider = empty(provider#clipboard#Executable()) ? 1 : 2
calling provider#clipboard#Executable()

line 1:   if exists('g:clipboard')
line 2:     if type({}) isnot# type(g:clipboard) || type({}) isnot# type(get(g:clipboard, 'copy', v:null)) || type({}) isnot# type(get(g:clipboard, 'paste', v:null))
line 5:       let s:err = 'clipboard: invalid g:clipboard'
line 6:       return ''
line 7:     endif
line 8: 
line 9:     let s:copy = {}
line 10:     let s:copy['+'] = s:split_cmd(get(g:clipboard.copy, '+', v:null))
line 11:     let s:copy['*'] = s:split_cmd(get(g:clipboard.copy, '*', v:null))
line 12: 
line 13:     let s:paste = {}
line 14:     let s:paste['+'] = s:split_cmd(get(g:clipboard.paste, '+', v:null))
line 15:     let s:paste['*'] = s:split_cmd(get(g:clipboard.paste, '*', v:null))
line 16: 
line 17:     let s:cache_enabled = get(g:clipboard, 'cache_enabled', 0)
line 18:     return get(g:clipboard, 'name', 'g:clipboard')
line 19:   elseif has('mac')
line 20:     let s:copy['+'] = ['pbcopy']
line 21:     let s:paste['+'] = ['pbpaste']
line 22:     let s:copy['*'] = s:copy['+']
line 23:     let s:paste['*'] = s:paste['+']
line 24:     let s:cache_enabled = 0
line 25:     return 'pbcopy'
line 26:   elseif !empty($WAYLAND_DISPLAY) && executable('wl-copy') && executable('wl-paste')
line 27:     let s:copy['+'] = ['wl-copy', '--foreground', '--type', 'text/plain']
line 28:     let s:paste['+'] = ['wl-paste', '--no-newline']
line 29:     let s:copy['*'] = ['wl-copy', '--foreground', '--primary', '--type', 'text/plain']
line 30:     let s:paste['*'] = ['wl-paste', '--no-newline', '--primary']
line 31:     return 'wl-copy'
line 32:   elseif !empty($DISPLAY) && executable('xclip')
line 33:     let s:copy['+'] = ['xclip', '-quiet', '-i', '-selection', 'clipboard']
line 34:     let s:paste['+'] = ['xclip', '-o', '-selection', 'clipboard']
line 35:     let s:copy['*'] = ['xclip', '-quiet', '-i', '-selection', 'primary']
line 36:     let s:paste['*'] = ['xclip', '-o', '-selection', 'primary']
line 37:     return 'xclip'
provider#clipboard#Executable returning 'xclip'

continuing in /usr/share/nvim/runtime/autoload/provider/clipboard.vim

finished sourcing /usr/share/nvim/runtime/autoload/provider/clipboard.vim

--- Terminal info --- {{{
&term: tmux-256color
Description: tmux with 256 colors
Aliases: tmux-256color
Boolean capabilities:
  auto_left_margin          bw         = false
  auto_right_margin         am         = true
  no_esc_ctlc               xsb        = false
  ceol_standout_glitch      xhp        = false
  eat_newline_glitch        xenl       = true
  erase_overstrike          eo         = false
  generic_type              gn         = false
  hard_copy                 hc         = false
  has_meta_key              km         = true
  has_status_line           hs         = true
  insert_null_glitch        in         = false
  memory_above              da         = false
  memory_below              db         = false
  move_insert_mode          mir        = true
  move_standout_mode        msgr       = true
  over_strike               os         = false
  status_line_esc_ok        eslok      = false
  dest_tabs_magic_smso      xt         = false
  tilde_glitch              hz         = false
  transparent_underline     ul         = false
  xon_xoff                  xon        = false
  needs_xon_xoff            nxon       = false
  prtr_silent               mc5i       = false
  hard_cursor               chts       = false
  non_rev_rmcup             nrrmc      = false
  no_pad_char               npc        = false
  non_dest_scroll_region    ndscr      = false
  can_change                ccc        = false
  back_color_erase          bce        = false
  hue_lightness_saturation  hls        = false
  col_addr_glitch           xhpa       = false
  cr_cancels_micro_mode     crxm       = false
  has_print_wheel           daisy      = false
  row_addr_glitch           xvpa       = false
  semi_auto_right_margin    sam        = false
  cpi_changes_res           cpix       = false
  lpi_changes_res           lpix       = false
  backspaces_with_bs        OTbs       = true
  crt_no_scrolling          OTns       = false
  no_correctly_working_cr   OTnc       = false
  gnu_has_meta_key          OTMT       = false
  linefeed_is_newline       OTNL       = false
  has_hardware_tabs         OTpt       = true
  return_does_clr_eol       OTxr       = false
Numeric capabilities:
  columns                   cols       = 80
  init_tabs                 it         = 8
  lines                     lines      = 24
  lines_of_memory           lm         = -1
  magic_cookie_glitch       xmc        = -1
  padding_baud_rate         pb         = -1
  virtual_terminal          vt         = -1
  width_status_line         wsl        = -1
  num_labels                nlab       = -1
  label_height              lh         = -1
  label_width               lw         = -1
  max_attributes            ma         = -1
  maximum_windows           wnum       = -1
  max_colors                colors     = 256
  max_pairs                 pairs      = 65536
  no_color_video            ncv        = -1
  buffer_capacity           bufsz      = -1
  dot_vert_spacing          spinv      = -1
  dot_horz_spacing          spinh      = -1
  max_micro_address         maddr      = -1
  max_micro_jump            mjump      = -1
  micro_col_size            mcs        = -1
  micro_line_size           mls        = -1
  number_of_pins            npins      = -1
  output_res_char           orc        = -1
  output_res_line           orl        = -1
  output_res_horz_inch      orhi       = -1
  output_res_vert_inch      orvi       = -1
  print_rate                cps        = -1
  wide_char_size            widcs      = -1
  buttons                   btns       = -1
  bit_image_entwining       bitwin     = -1
  bit_image_type            bitype     = -1
  magic_cookie_glitch_ul    OTug       = -1
  carriage_return_delay     OTdC       = -1
  new_line_delay            OTdN       = -1
  backspace_delay           OTdB       = -1
  horizontal_tab_delay      OTdT       = -1
  number_of_function_keys   OTkn       = -1
String capabilities:
  back_tab                  cbt        = <Esc>[Z
  bell                      bel        = <C-G>
  carriage_return           cr         = <CR>
  change_scroll_region      csr        = <Esc>[%i%p1%d;%p2%dr
  clear_all_tabs            tbc        = <Esc>[3g
  clear_screen              clear      = <Esc>[H<Esc>[J
  clr_eol                   el         = <Esc>[K
  clr_eos                   ed         = <Esc>[J
  column_address            hpa        = <Esc>[%i%p1%dG
  cursor_address            cup        = <Esc>[%i%p1%d;%p2%dH
  cursor_down               cud1       = <NL>
  cursor_home               home       = <Esc>[H
  cursor_invisible          civis      = <Esc>[?25l
  cursor_left               cub1       = <C-H>
  cursor_normal             cnorm      = <Esc>[34h<Esc>[?25h
  cursor_right              cuf1       = <Esc>[C
  cursor_up                 cuu1       = <Esc>M
  cursor_visible            cvvis      = <Esc>[34l
  delete_character          dch1       = <Esc>[P
  delete_line               dl1        = <Esc>[M
  dis_status_line           dsl        = <Esc>]0;<C-G>
  enter_alt_charset_mode    smacs      = <C-N>
  enter_blink_mode          blink      = <Esc>[5m
  enter_bold_mode           bold       = <Esc>[1m
  enter_ca_mode             smcup      = <Esc>[?1049h
  enter_dim_mode            dim        = <Esc>[2m
  enter_insert_mode         smir       = <Esc>[4h
  enter_secure_mode         invis      = <Esc>[8m
  enter_reverse_mode        rev        = <Esc>[7m
  enter_standout_mode       smso       = <Esc>[7m
  enter_underline_mode      smul       = <Esc>[4m
  exit_alt_charset_mode     rmacs      = <C-O>
  exit_attribute_mode       sgr0       = <Esc>[m<C-O>
  exit_ca_mode              rmcup      = <Esc>[?1049l
  exit_insert_mode          rmir       = <Esc>[4l
  exit_standout_mode        rmso       = <Esc>[27m
  exit_underline_mode       rmul       = <Esc>[24m
  flash_screen              flash      = <Esc>g
  from_status_line          fsl        = <C-G>
  init_2string              is2        = <Esc>)0
  insert_line               il1        = <Esc>[L
  key_backspace             kbs        = ^?
  key_dc                    kdch1      = <Esc>[3~
  key_down                  kcud1      = <Esc>OB
  key_f1                    kf1        = <Esc>OP
  key_f10                   kf10       = <Esc>[21~
  key_f2                    kf2        = <Esc>OQ
  key_f3                    kf3        = <Esc>OR
  key_f4                    kf4        = <Esc>OS
  key_f5                    kf5        = <Esc>[15~
  key_f6                    kf6        = <Esc>[17~
  key_f7                    kf7        = <Esc>[18~
  key_f8                    kf8        = <Esc>[19~
  key_f9                    kf9        = <Esc>[20~
  key_home                  khome      = <Esc>[1~
  key_ic                    kich1      = <Esc>[2~
  key_left                  kcub1      = <Esc>OD
  key_npage                 knp        = <Esc>[6~
  key_ppage                 kpp        = <Esc>[5~
  key_right                 kcuf1      = <Esc>OC
  key_sf                    kind       = <Esc>[1;2B
  key_sr                    kri        = <Esc>[1;2A
  key_up                    kcuu1      = <Esc>OA
  keypad_local              rmkx       = <Esc>[?1l<Esc>>
  keypad_xmit               smkx       = <Esc>[?1h<Esc>=
  newline                   nel        = <Esc>E
  parm_dch                  dch        = <Esc>[%p1%dP
  parm_delete_line          dl         = <Esc>[%p1%dM
  parm_down_cursor          cud        = <Esc>[%p1%dB
  parm_ich                  ich        = <Esc>[%p1%d@
  parm_index                indn       = <Esc>[%p1%dS
  parm_insert_line          il         = <Esc>[%p1%dL
  parm_left_cursor          cub        = <Esc>[%p1%dD
  parm_right_cursor         cuf        = <Esc>[%p1%dC
  parm_rindex               rin        = <Esc>[%p1%dT
  parm_up_cursor            cuu        = <Esc>[%p1%dA
  reset_2string             rs2        = <Esc>c<Esc>[?1000l<Esc>[?25h
  restore_cursor            rc         = <Esc>8
  row_address               vpa        = <Esc>[%i%p1%dd
  save_cursor               sc         = <Esc>7
  scroll_forward            ind        = <NL>
  scroll_reverse            ri         = <Esc>M
  set_attributes            sgr        = <Esc>[0%?%p6%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;%?%p5%t;2%;%?%p7%t;8%;m%?%p9%t<C-N>%e<C-O>%;
  set_tab                   hts        = <Esc>H
  tab                       ht         = <Tab>
  to_status_line            tsl        = <Esc>]0;
  acs_chars                 acsc       = ++,,--..00``aaffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~
  key_btab                  kcbt       = <Esc>[Z
  ena_acs                   enacs      = <Esc>(B<Esc>)0
  key_end                   kend       = <Esc>[4~
  key_sdc                   kDC        = <Esc>[3;2~
  key_send                  kEND       = <Esc>[1;2F
  key_shome                 kHOM       = <Esc>[1;2H
  key_sic                   kIC        = <Esc>[2;2~
  key_sleft                 kLFT       = <Esc>[1;2D
  key_snext                 kNXT       = <Esc>[6;2~
  key_sprevious             kPRV       = <Esc>[5;2~
  key_sright                kRIT       = <Esc>[1;2C
  key_f11                   kf11       = <Esc>[23~
  key_f12                   kf12       = <Esc>[24~
  key_f13                   kf13       = <Esc>[1;2P
  key_f14                   kf14       = <Esc>[1;2Q
  key_f15                   kf15       = <Esc>[1;2R
  key_f16                   kf16       = <Esc>[1;2S
  key_f17                   kf17       = <Esc>[15;2~
  key_f18                   kf18       = <Esc>[17;2~
  key_f19                   kf19       = <Esc>[18;2~
  key_f20                   kf20       = <Esc>[19;2~
  key_f21                   kf21       = <Esc>[20;2~
  key_f22                   kf22       = <Esc>[21;2~
  key_f23                   kf23       = <Esc>[23;2~
  key_f24                   kf24       = <Esc>[24;2~
  key_f25                   kf25       = <Esc>[1;5P
  key_f26                   kf26       = <Esc>[1;5Q
  key_f27                   kf27       = <Esc>[1;5R
  key_f28                   kf28       = <Esc>[1;5S
  key_f29                   kf29       = <Esc>[15;5~
  key_f30                   kf30       = <Esc>[17;5~
  key_f31                   kf31       = <Esc>[18;5~
  key_f32                   kf32       = <Esc>[19;5~
  key_f33                   kf33       = <Esc>[20;5~
  key_f34                   kf34       = <Esc>[21;5~
  key_f35                   kf35       = <Esc>[23;5~
  key_f36                   kf36       = <Esc>[24;5~
  key_f37                   kf37       = <Esc>[1;6P
  key_f38                   kf38       = <Esc>[1;6Q
  key_f39                   kf39       = <Esc>[1;6R
  key_f40                   kf40       = <Esc>[1;6S
  key_f41                   kf41       = <Esc>[15;6~
  key_f42                   kf42       = <Esc>[17;6~
  key_f43                   kf43       = <Esc>[18;6~
  key_f44                   kf44       = <Esc>[19;6~
  key_f45                   kf45       = <Esc>[20;6~
  key_f46                   kf46       = <Esc>[21;6~
  key_f47                   kf47       = <Esc>[23;6~
  key_f48                   kf48       = <Esc>[24;6~
  key_f49                   kf49       = <Esc>[1;3P
  key_f50                   kf50       = <Esc>[1;3Q
  key_f51                   kf51       = <Esc>[1;3R
  key_f52                   kf52       = <Esc>[1;3S
  key_f53                   kf53       = <Esc>[15;3~
  key_f54                   kf54       = <Esc>[17;3~
  key_f55                   kf55       = <Esc>[18;3~
  key_f56                   kf56       = <Esc>[19;3~
  key_f57                   kf57       = <Esc>[20;3~
  key_f58                   kf58       = <Esc>[21;3~
  key_f59                   kf59       = <Esc>[23;3~
  key_f60                   kf60       = <Esc>[24;3~
  key_f61                   kf61       = <Esc>[1;4P
  key_f62                   kf62       = <Esc>[1;4Q
  key_f63                   kf63       = <Esc>[1;4R
  clr_bol                   el1        = <Esc>[1K
  user6                     u6         = <Esc>[%i%d;%dR
  user7                     u7         = <Esc>[6n
  user8                     u8         = <Esc>[?1;2c
  user9                     u9         = <Esc>[c
  orig_pair                 op         = <Esc>[39;49m
  enter_italics_mode        sitm       = <Esc>[3m
  exit_italics_mode         ritm       = <Esc>[23m
  key_mouse                 kmous      = <Esc>[M
  set_a_foreground          setaf      = <Esc>[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m
  set_a_background          setab      = <Esc>[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m
Extended boolean capabilities:
  AX                        = true
  G0                        = true
Extended numeric capabilities:
  U8                        = 1
Extended string capabilities:
  BD                        = <Esc>[?2004l
  BE                        = <Esc>[?2004h
  Cr                        = <Esc>]112<C-G>
  Cs                        = <Esc>]12;%p1%s<C-G>
  E0                        = <Esc>(B
  E3                        = <Esc>[3J
  Ms                        = <Esc>]52;%p1%s;%p2%s<C-G>
  PE                        = <Esc>[201~
  PS                        = <Esc>[200~
  S0                        = <Esc>(%p1%c
  Se                        = <Esc>[2 q
  Smulx                     = <Esc>[4:%p1%dm
  Ss                        = <Esc>[%p1%d q
  TS                        = <Esc>]0;
  kDC3                      = <Esc>[3;3~
  kDC4                      = <Esc>[3;4~
  kDC5                      = <Esc>[3;5~
  kDC6                      = <Esc>[3;6~
  kDC7                      = <Esc>[3;7~
  kDN                       = <Esc>[1;2B
  kDN3                      = <Esc>[1;3B
  kDN4                      = <Esc>[1;4B
  kDN5                      = <Esc>[1;5B
  kDN6                      = <Esc>[1;6B
  kDN7                      = <Esc>[1;7B
  kEND3                     = <Esc>[1;3F
  kEND4                     = <Esc>[1;4F
  kEND5                     = <Esc>[1;5F
  kEND6                     = <Esc>[1;6F
  kEND7                     = <Esc>[1;7F
  kHOM3                     = <Esc>[1;3H
  kHOM4                     = <Esc>[1;4H
  kHOM5                     = <Esc>[1;5H
  kHOM6                     = <Esc>[1;6H
  kHOM7                     = <Esc>[1;7H
  kIC3                      = <Esc>[2;3~
  kIC4                      = <Esc>[2;4~
  kIC5                      = <Esc>[2;5~
  kIC6                      = <Esc>[2;6~
  kIC7                      = <Esc>[2;7~
  kLFT3                     = <Esc>[1;3D
  kLFT4                     = <Esc>[1;4D
  kLFT5                     = <Esc>[1;5D
  kLFT6                     = <Esc>[1;6D
  kLFT7                     = <Esc>[1;7D
  kNXT3                     = <Esc>[6;3~
  kNXT4                     = <Esc>[6;4~
  kNXT5                     = <Esc>[6;5~
  kNXT6                     = <Esc>[6;6~
  kNXT7                     = <Esc>[6;7~
  kPRV3                     = <Esc>[5;3~
  kPRV4                     = <Esc>[5;4~
  kPRV5                     = <Esc>[5;5~
  kPRV6                     = <Esc>[5;6~
  kPRV7                     = <Esc>[5;7~
  kRIT3                     = <Esc>[1;3C
  kRIT4                     = <Esc>[1;4C
  kRIT5                     = <Esc>[1;5C
  kRIT6                     = <Esc>[1;6C
  kRIT7                     = <Esc>[1;7C
  kUP                       = <Esc>[1;2A
  kUP3                      = <Esc>[1;3A
  kUP4                      = <Esc>[1;4A
  kUP5                      = <Esc>[1;5A
  kUP6                      = <Esc>[1;6A
  kUP7                      = <Esc>[1;7A
  rmxx                      = <Esc>[29m
  smxx                      = <Esc>[9m
  ext.get_bg                = <Esc>]11;?<C-G>
  ext.get_extkeys           = <Esc>[?u<Esc>[c
  setrgbf                   = <Esc>[38;2;%p1%d;%p2%d;%p3%dm
  setrgbb                   = <Esc>[48;2;%p1%d;%p2%d;%p3%dm
  ext.save_title            = <Esc>[22;0t
  ext.restore_title         = <Esc>[23;0t
  ext.enable_lr_margin      = <Esc>[?69h
  ext.disable_lr_margin     = <Esc>[?69l
  ext.enable_bpaste         = <Esc>[?2004h
  ext.disable_bpaste        = <Esc>[?2004l
  ext.enable_focus          = <Esc>[?1004h
  ext.disable_focus         = <Esc>[?1004l
  ext.enable_mouse          = <Esc>[?1002h<Esc>[?1006h
  ext.disable_mouse         = <Esc>[?1002l<Esc>[?1006l
  ext.enable_mouse_move     = <Esc>[?1003h
  ext.disable_mouse_move    = <Esc>[?1003l
  ext.set_underline_color   = <Esc>[58:2::%p1%d:%p2%d:%p3%dm
  ext.enable_extended_keys  = <Esc>[>4;2m
  ext.disable_extended_keys = <Esc>[>4;0m
}}}

calling <SNR>40_PollServerReady(1)

line 1:   if !py3eval( 'ycm_state.IsServerAlive()' )
calling provider#python3#Call('eval', ['ycm_state.IsServerAlive()'])

line 1:   if s:err != ''
line 2:     return
line 3:   endif
line 4:   if !exists('s:host')
line 5:     let s:rpcrequest = function('rpcrequest')
line 6: 
line 7:     " Ensure that we can load the Python3 host before bootstrapping
line 8:     try
line 9:       let s:host = remote#host#Require('legacy-python3-provider')
line 10:     catch
line 11:       let s:err = v:exception
line 12:       echohl WarningMsg
line 13:       echomsg v:exception
line 14:       echohl None
line 15:       return
line 16:     endtry
line 17:   endif
line 18:   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))
provider#python3#Call returning v:true

continuing in <SNR>40_PollServerReady

line 2:     py3 ycm_state.NotifyUserIfServerCrashed()
line 3:     " Server crashed. Don't poll it again.
line 4:     return
line 5:   endif
line 6: 
line 7:   if !py3eval( 'ycm_state.CheckIfServerIsReady()' )
calling provider#python3#Call('eval', ['ycm_state.CheckIfServerIsReady()'])

line 1:   if s:err != ''
line 2:     return
line 3:   endif
line 4:   if !exists('s:host')
line 5:     let s:rpcrequest = function('rpcrequest')
line 6: 
line 7:     " Ensure that we can load the Python3 host before bootstrapping
line 8:     try
line 9:       let s:host = remote#host#Require('legacy-python3-provider')
line 10:     catch
line 11:       let s:err = v:exception
line 12:       echohl WarningMsg
line 13:       echomsg v:exception
line 14:       echohl None
line 15:       return
line 16:     endtry
line 17:   endif
line 18:   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))
provider#python3#Call returning v:null

continuing in <SNR>40_PollServerReady

line 8:     let s:pollers.server_ready.id = timer_start( s:pollers.server_ready.wait_milliseconds, function( 's:PollServerReady' ) )
line 11:     return
<SNR>40_PollServerReady returning #0

calling <SNR>40_PollServerReady(2)

line 1:   if !py3eval( 'ycm_state.IsServerAlive()' )
calling provider#python3#Call('eval', ['ycm_state.IsServerAlive()'])

line 1:   if s:err != ''
line 2:     return
line 3:   endif
line 4:   if !exists('s:host')
line 5:     let s:rpcrequest = function('rpcrequest')
line 6: 
line 7:     " Ensure that we can load the Python3 host before bootstrapping
line 8:     try
line 9:       let s:host = remote#host#Require('legacy-python3-provider')
line 10:     catch
line 11:       let s:err = v:exception
line 12:       echohl WarningMsg
line 13:       echomsg v:exception
line 14:       echohl None
line 15:       return
line 16:     endtry
line 17:   endif
line 18:   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))
provider#python3#Call returning v:true

continuing in <SNR>40_PollServerReady

line 2:     py3 ycm_state.NotifyUserIfServerCrashed()
line 3:     " Server crashed. Don't poll it again.
line 4:     return
line 5:   endif
line 6: 
line 7:   if !py3eval( 'ycm_state.CheckIfServerIsReady()' )
calling provider#python3#Call('eval', ['ycm_state.CheckIfServerIsReady()'])

line 1:   if s:err != ''
line 2:     return
line 3:   endif
line 4:   if !exists('s:host')
line 5:     let s:rpcrequest = function('rpcrequest')
line 6: 
line 7:     " Ensure that we can load the Python3 host before bootstrapping
line 8:     try
line 9:       let s:host = remote#host#Require('legacy-python3-provider')
line 10:     catch
line 11:       let s:err = v:exception
line 12:       echohl WarningMsg
line 13:       echomsg v:exception
line 14:       echohl None
line 15:       return
line 16:     endtry
line 17:   endif
line 18:   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))
provider#python3#Call returning v:true

continuing in <SNR>40_PollServerReady

line 8:     let s:pollers.server_ready.id = timer_start( s:pollers.server_ready.wait_milliseconds, function( 's:PollServerReady' ) )
line 11:     return
line 12:   endif
line 13: 
line 14:   call s:OnFileTypeSet()
calling <SNR>40_OnFileTypeSet()

line 1:   " The contents of the command-line window are empty when the filetype is set
line 2:   " for the first time. Users should never change its filetype so we only rely
line 3:   " on the CmdwinEnter event for that window.
line 4:   if !empty( getcmdwintype() )
line 5:     return
line 6:   endif
line 7: 
line 8:   if !s:AllowedToCompleteInCurrentBuffer()
calling <SNR>40_AllowedToCompleteInCurrentBuffer()

line 1:   return s:AllowedToCompleteInBuffer( '%' )
calling <SNR>40_AllowedToCompleteInBuffer('%')

line 1:   let buftype = getbufvar( a:buffer, '&buftype' )
line 2: 
line 3:   if has_key( s:buftype_blacklist, buftype )
line 4:     return 0
line 5:   endif
line 6: 
line 7:   let filetype = getbufvar( a:buffer, '&filetype' )
line 8:   if empty( filetype )
line 9:     let filetype = 'ycm_nofiletype'
line 10:   endif
line 11: 
line 12:   let allowed = youcompleteme#filetypes#AllowedForFiletype( filetype )
Searching for "autoload/youcompleteme/filetypes.vim" in runtime path
Searching for "/home/burp/.config/nvim/autoload/youcompleteme/filetypes.vim"
Searching for "/home/burp/.vim/bundle/Vundle.vim/autoload/youcompleteme/filetypes.vim"
Searching for "/home/burp/.vim/bundle/YouCompleteMe/autoload/youcompleteme/filetypes.vim"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/.vim/bundle/YouCompleteMe/autoload/youcompleteme)
chdir(/home/burp/Applications/.bash_aliases)
line 12: sourcing "/home/burp/.vim/bundle/YouCompleteMe/autoload/youcompleteme/filetypes.vim"
line 1: " Copyright (C) 2011-2018 YouCompleteMe contributors
line 2: "
line 3: " This file is part of YouCompleteMe.
line 4: "
line 5: " YouCompleteMe is free software: you can redistribute it and/or modify
line 6: " it under the terms of the GNU General Public License as published by
line 7: " the Free Software Foundation, either version 3 of the License, or
line 8: " (at your option) any later version.
line 9: "
line 10: " YouCompleteMe is distributed in the hope that it will be useful,
line 11: " but WITHOUT ANY WARRANTY; without even the implied warranty of
line 12: " MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
line 13: " GNU General Public License for more details.
line 14: "
line 15: " You should have received a copy of the GNU General Public License
line 16: " along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.
line 17: 
line 18: 
line 19: function! s:HasAnyKey( dict, keys ) abort
line 27: 
line 28: function! youcompleteme#filetypes#AllowedForFiletype( filetype ) abort
finished sourcing /home/burp/.vim/bundle/YouCompleteMe/autoload/youcompleteme/filetypes.vim
continuing in <SNR>40_AllowedToCompleteInBuffer
calling youcompleteme#filetypes#AllowedForFiletype('ycm_nofiletype')

line 1:   let whitelist_allows = type( g:ycm_filetype_whitelist ) != v:t_dict || has_key( g:ycm_filetype_whitelist, '*' ) || s:HasAnyKey( g:ycm_filetype_whitelist, split( a:filetype, '\.' ) )
line 4:   let blacklist_allows = type( g:ycm_filetype_blacklist ) != v:t_dict || !s:HasAnyKey( g:ycm_filetype_blacklist, split( a:filetype, '\.' ) )
calling <SNR>43_HasAnyKey({'notes': 1, 'markdown': 1, 'netrw': 1... 1, 'text': 1, 'infolog': 1, 'mail': 1}, ['ycm_nofiletype'])

line 1:   for key in a:keys
line 2:     if has_key( a:dict, key )
line 3:       return 1
<SNR>43_HasAnyKey returning #1

continuing in youcompleteme#filetypes#AllowedForFiletype

line 6: 
line 7:   return whitelist_allows && blacklist_allows
youcompleteme#filetypes#AllowedForFiletype returning #0

continuing in <SNR>40_AllowedToCompleteInBuffer

line 13: 
line 14:   if !allowed || s:DisableOnLargeFile( a:buffer )
line 15:     return 0
<SNR>40_AllowedToCompleteInBuffer returning #0

continuing in <SNR>40_AllowedToCompleteInCurrentBuffer

<SNR>40_AllowedToCompleteInCurrentBuffer returning #0

continuing in <SNR>40_OnFileTypeSet

line 9:     return
<SNR>40_OnFileTypeSet returning #0

continuing in <SNR>40_PollServerReady

<SNR>40_PollServerReady returning #0


Executing: qrecording @q
Executing BufLeave Autocommands for "*"
autocommand if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif

Executing: if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
Executing: let w:netrw_prvfile= expand("%:p")|endif
Executing: endif
Executing WinLeave Autocommands for "*"
autocommand call s:Remove_Matches()

Executing: call s:Remove_Matches()
calling <SNR>28_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     silent! call matchdelete(3)
line 3:     let w:paren_hl_on = 0
line 4:   endif
<SNR>28_Remove_Matches returning #0

continuing in WinLeave Autocommands for "*"

Executing WinEnter Autocommands for "*"
autocommand let s:tmux_is_last_pane = 0

Executing: let s:tmux_is_last_pane = 0
Executing WinEnter Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>28_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   call s:Remove_Matches()
calling <SNR>28_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     silent! call matchdelete(3)
line 3:     let w:paren_hl_on = 0
line 4:   endif
<SNR>28_Remove_Matches returning #0

continuing in <SNR>28_Highlight_Matching_Pair

line 3: 
line 4:   " Avoid that we remove the popup menu.
line 5:   " Return when there are no colors (looks like the cursor jumps).
line 6:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 7:     return
line 8:   endif
line 9: 
line 10:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 11:   let c_lnum = line('.')
line 12:   let c_col = col('.')
line 13:   let before = 0
line 14: 
line 15:   let text = getline(c_lnum)
line 16:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 17:   if empty(matches)
line 18:     let [c_before, c] = ['', '']
line 19:   else
line 20:     let [c_before, c] = matches[1:2]
line 21:   endif
line 22:   let plist = split(&matchpairs, '.\zs[:,]')
line 23:   let i = index(plist, c)
line 24:   if i < 0
line 25:     " not found, in Insert mode try character before the cursor
line 26:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 27:       let before = strlen(c_before)
line 28:       let c = c_before
line 29:       let i = index(plist, c)
line 30:     endif
line 31:     if i < 0
line 32:       " not found, nothing to do
line 33:       return
<SNR>28_Highlight_Matching_Pair returning #0

continuing in WinEnter Autocommands for "*"

Executing WinEnter Autocommands for "*"
autocommand call s:dopopd()

Executing: call s:dopopd()
calling <SNR>38_dopopd()

line 1:   if !exists('w:fzf_pushd')
line 2:     return
<SNR>38_dopopd returning #0

continuing in WinEnter Autocommands for "*"

Executing WinEnter Autocommands for "*"
autocommand call s:OnBufferEnter()

Executing: call s:OnBufferEnter()
calling <SNR>40_OnBufferEnter()

line 1:   call s:StartMessagePoll()
calling <SNR>40_StartMessagePoll()

line 1:   if s:pollers.receive_messages.id < 0
line 2:     let s:pollers.receive_messages.id = timer_start( s:pollers.receive_messages.wait_milliseconds, function( 's:ReceiveMessages' ) )
line 5:   endif
<SNR>40_StartMessagePoll returning #0

continuing in <SNR>40_OnBufferEnter

line 2:   if !s:VisitedBufferRequiresReparse()
calling <SNR>40_VisitedBufferRequiresReparse()

line 1:   if bufnr( '%' ) ==# s:previous_allowed_buffer_number
line 2:     return 0
line 3:   endif
line 4: 
line 5:   return s:AllowedToCompleteInCurrentBuffer()
calling <SNR>40_AllowedToCompleteInCurrentBuffer()

line 1:   return s:AllowedToCompleteInBuffer( '%' )
calling <SNR>40_AllowedToCompleteInBuffer('%')

line 1:   let buftype = getbufvar( a:buffer, '&buftype' )
line 2: 
line 3:   if has_key( s:buftype_blacklist, buftype )
line 4:     return 0
line 5:   endif
line 6: 
line 7:   let filetype = getbufvar( a:buffer, '&filetype' )
line 8:   if empty( filetype )
line 9:     let filetype = 'ycm_nofiletype'
line 10:   endif
line 11: 
line 12:   let allowed = youcompleteme#filetypes#AllowedForFiletype( filetype )
calling youcompleteme#filetypes#AllowedForFiletype('ycm_nofiletype')

line 1:   let whitelist_allows = type( g:ycm_filetype_whitelist ) != v:t_dict || has_key( g:ycm_filetype_whitelist, '*' ) || s:HasAnyKey( g:ycm_filetype_whitelist, split( a:filetype, '\.' ) )
line 4:   let blacklist_allows = type( g:ycm_filetype_blacklist ) != v:t_dict || !s:HasAnyKey( g:ycm_filetype_blacklist, split( a:filetype, '\.' ) )
calling <SNR>43_HasAnyKey({'notes': 1, 'markdown': 1, 'netrw': 1... 1, 'text': 1, 'infolog': 1, 'mail': 1}, ['ycm_nofiletype'])

line 1:   for key in a:keys
line 2:     if has_key( a:dict, key )
line 3:       return 1
<SNR>43_HasAnyKey returning #1

continuing in youcompleteme#filetypes#AllowedForFiletype

line 6: 
line 7:   return whitelist_allows && blacklist_allows
youcompleteme#filetypes#AllowedForFiletype returning #0

continuing in <SNR>40_AllowedToCompleteInBuffer

line 13: 
line 14:   if !allowed || s:DisableOnLargeFile( a:buffer )
line 15:     return 0
<SNR>40_AllowedToCompleteInBuffer returning #0

continuing in <SNR>40_AllowedToCompleteInCurrentBuffer

<SNR>40_AllowedToCompleteInCurrentBuffer returning #0

continuing in <SNR>40_VisitedBufferRequiresReparse

<SNR>40_VisitedBufferRequiresReparse returning #0

continuing in <SNR>40_OnBufferEnter

line 3:     return
<SNR>40_OnBufferEnter returning #0

continuing in WinEnter Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand sil call s:LocalBrowse(expand("<amatch>"))

Executing: sil call s:LocalBrowse(expand("<amatch>"))
calling <SNR>29_LocalBrowse('')

line 1:   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
line 2:   " Otherwise, the BufEnter event gets triggered when attempts to write to
line 3:   " the DBG buffer are made.
line 4: 
line 5:   if !exists("s:vimentered")
line 6:    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
line 7:    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
line 8: "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
line 9: "   call Dret("s:LocalBrowse")
line 10:    return
line 11:   endif
line 12: 
line 13: "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
line 14: 
line 15:   if has("amiga")
line 16:    " The check against '' is made for the Amiga, where the empty
line 17:    " string is the current directory and not checking would break
line 18:    " things such as the help command.
line 19: "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
line 20:    if a:dirname != '' && isdirectory(a:dirname)
line 21:     sil! call netrw#LocalBrowseCheck(a:dirname)
line 22:     if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
line 23:      exe w:netrw_bannercnt
line 24:     endif
line 25:    endif
line 26: 
line 27:   elseif isdirectory(a:dirname)
line 28: "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
line 29: "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
line 30:    " Jul 13, 2021: for whatever reason, preceding the following call with
line 31:    " a   sil!  causes an unbalanced if-endif vim error
line 32:    call netrw#LocalBrowseCheck(a:dirname)
line 33:    if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
line 34:     exe w:netrw_bannercnt
line 35:    endif
line 36: 
line 37:   else
line 38:    " not a directory, ignore it
line 39: "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
line 40:   endif
line 41: 
line 42: "  call Dret("s:LocalBrowse")
<SNR>29_LocalBrowse returning #0

continuing in BufEnter Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand call s:OnBufferEnter()

Executing: call s:OnBufferEnter()
calling <SNR>40_OnBufferEnter()

line 1:   call s:StartMessagePoll()
calling <SNR>40_StartMessagePoll()

line 1:   if s:pollers.receive_messages.id < 0
line 2:     let s:pollers.receive_messages.id = timer_start( s:pollers.receive_messages.wait_milliseconds, function( 's:ReceiveMessages' ) )
line 5:   endif
<SNR>40_StartMessagePoll returning #0

continuing in <SNR>40_OnBufferEnter

line 2:   if !s:VisitedBufferRequiresReparse()
calling <SNR>40_VisitedBufferRequiresReparse()

line 1:   if bufnr( '%' ) ==# s:previous_allowed_buffer_number
line 2:     return 0
line 3:   endif
line 4: 
line 5:   return s:AllowedToCompleteInCurrentBuffer()
calling <SNR>40_AllowedToCompleteInCurrentBuffer()

line 1:   return s:AllowedToCompleteInBuffer( '%' )
calling <SNR>40_AllowedToCompleteInBuffer('%')

line 1:   let buftype = getbufvar( a:buffer, '&buftype' )
line 2: 
line 3:   if has_key( s:buftype_blacklist, buftype )
line 4:     return 0
line 5:   endif
line 6: 
line 7:   let filetype = getbufvar( a:buffer, '&filetype' )
line 8:   if empty( filetype )
line 9:     let filetype = 'ycm_nofiletype'
line 10:   endif
line 11: 
line 12:   let allowed = youcompleteme#filetypes#AllowedForFiletype( filetype )
calling youcompleteme#filetypes#AllowedForFiletype('ycm_nofiletype')

line 1:   let whitelist_allows = type( g:ycm_filetype_whitelist ) != v:t_dict || has_key( g:ycm_filetype_whitelist, '*' ) || s:HasAnyKey( g:ycm_filetype_whitelist, split( a:filetype, '\.' ) )
line 4:   let blacklist_allows = type( g:ycm_filetype_blacklist ) != v:t_dict || !s:HasAnyKey( g:ycm_filetype_blacklist, split( a:filetype, '\.' ) )
calling <SNR>43_HasAnyKey({'notes': 1, 'markdown': 1, 'netrw': 1... 1, 'text': 1, 'infolog': 1, 'mail': 1}, ['ycm_nofiletype'])

line 1:   for key in a:keys
line 2:     if has_key( a:dict, key )
line 3:       return 1
<SNR>43_HasAnyKey returning #1

continuing in youcompleteme#filetypes#AllowedForFiletype

line 6: 
line 7:   return whitelist_allows && blacklist_allows
youcompleteme#filetypes#AllowedForFiletype returning #0

continuing in <SNR>40_AllowedToCompleteInBuffer

line 13: 
line 14:   if !allowed || s:DisableOnLargeFile( a:buffer )
line 15:     return 0
<SNR>40_AllowedToCompleteInBuffer returning #0

continuing in <SNR>40_AllowedToCompleteInCurrentBuffer

<SNR>40_AllowedToCompleteInCurrentBuffer returning #0

continuing in <SNR>40_VisitedBufferRequiresReparse

<SNR>40_VisitedBufferRequiresReparse returning #0

continuing in <SNR>40_OnBufferEnter

line 3:     return
<SNR>40_OnBufferEnter returning #0

continuing in BufEnter Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>28_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   call s:Remove_Matches()
calling <SNR>28_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     silent! call matchdelete(3)
line 3:     let w:paren_hl_on = 0
line 4:   endif
<SNR>28_Remove_Matches returning #0

continuing in <SNR>28_Highlight_Matching_Pair

line 3: 
line 4:   " Avoid that we remove the popup menu.
line 5:   " Return when there are no colors (looks like the cursor jumps).
line 6:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 7:     return
line 8:   endif
line 9: 
line 10:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 11:   let c_lnum = line('.')
line 12:   let c_col = col('.')
line 13:   let before = 0
line 14: 
line 15:   let text = getline(c_lnum)
line 16:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 17:   if empty(matches)
line 18:     let [c_before, c] = ['', '']
line 19:   else
line 20:     let [c_before, c] = matches[1:2]
line 21:   endif
line 22:   let plist = split(&matchpairs, '.\zs[:,]')
line 23:   let i = index(plist, c)
line 24:   if i < 0
line 25:     " not found, in Insert mode try character before the cursor
line 26:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 27:       let before = strlen(c_before)
line 28:       let c = c_before
line 29:       let i = index(plist, c)
line 30:     endif
line 31:     if i < 0
line 32:       " not found, nothing to do
line 33:       return
<SNR>28_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:OnCursorMovedNormalMode()

Executing: call s:OnCursorMovedNormalMode()
calling <SNR>40_OnCursorMovedNormalMode()

line 1:   if !s:AllowedToCompleteInCurrentBuffer()
calling <SNR>40_AllowedToCompleteInCurrentBuffer()

line 1:   return s:AllowedToCompleteInBuffer( '%' )
calling <SNR>40_AllowedToCompleteInBuffer('%')

line 1:   let buftype = getbufvar( a:buffer, '&buftype' )
line 2: 
line 3:   if has_key( s:buftype_blacklist, buftype )
line 4:     return 0
line 5:   endif
line 6: 
line 7:   let filetype = getbufvar( a:buffer, '&filetype' )
line 8:   if empty( filetype )
line 9:     let filetype = 'ycm_nofiletype'
line 10:   endif
line 11: 
line 12:   let allowed = youcompleteme#filetypes#AllowedForFiletype( filetype )
calling youcompleteme#filetypes#AllowedForFiletype('ycm_nofiletype')

line 1:   let whitelist_allows = type( g:ycm_filetype_whitelist ) != v:t_dict || has_key( g:ycm_filetype_whitelist, '*' ) || s:HasAnyKey( g:ycm_filetype_whitelist, split( a:filetype, '\.' ) )
line 4:   let blacklist_allows = type( g:ycm_filetype_blacklist ) != v:t_dict || !s:HasAnyKey( g:ycm_filetype_blacklist, split( a:filetype, '\.' ) )
calling <SNR>43_HasAnyKey({'notes': 1, 'markdown': 1, 'netrw': 1... 1, 'text': 1, 'infolog': 1, 'mail': 1}, ['ycm_nofiletype'])

line 1:   for key in a:keys
line 2:     if has_key( a:dict, key )
line 3:       return 1
<SNR>43_HasAnyKey returning #1

continuing in youcompleteme#filetypes#AllowedForFiletype

line 6: 
line 7:   return whitelist_allows && blacklist_allows
youcompleteme#filetypes#AllowedForFiletype returning #0

continuing in <SNR>40_AllowedToCompleteInBuffer

line 13: 
line 14:   if !allowed || s:DisableOnLargeFile( a:buffer )
line 15:     return 0
<SNR>40_AllowedToCompleteInBuffer returning #0

continuing in <SNR>40_AllowedToCompleteInCurrentBuffer

<SNR>40_AllowedToCompleteInCurrentBuffer returning #0

continuing in <SNR>40_OnCursorMovedNormalMode

line 2:     return
<SNR>40_OnCursorMovedNormalMode returning #0

continuing in CursorMoved Autocommands for "*"

Executing BufUnload Autocommands for "*"
autocommand call s:OnBufferUnload()

Executing: call s:OnBufferUnload()
calling <SNR>40_OnBufferUnload()

line 1:   " Expanding <abuf> returns the unloaded buffer number as a string but we want
line 2:   " it as a true number for the getbufvar function.
line 3:   let buffer_number = str2nr( expand( '<abuf>' ) )
line 4:   if !s:AllowedToCompleteInBuffer( buffer_number )
calling <SNR>40_AllowedToCompleteInBuffer(2)

line 1:   let buftype = getbufvar( a:buffer, '&buftype' )
line 2: 
line 3:   if has_key( s:buftype_blacklist, buftype )
line 4:     return 0
<SNR>40_AllowedToCompleteInBuffer returning #0

continuing in <SNR>40_OnBufferUnload

line 5:     return
<SNR>40_OnBufferUnload returning #0

continuing in BufUnload Autocommands for "*"

recording @q
calling <SNR>40_ReceiveMessages(4)

line 1:   let poll_again = v:false
line 2:   if s:AllowedToCompleteInCurrentBuffer()
calling <SNR>40_AllowedToCompleteInCurrentBuffer()

line 1:   return s:AllowedToCompleteInBuffer( '%' )
calling <SNR>40_AllowedToCompleteInBuffer('%')

line 1:   let buftype = getbufvar( a:buffer, '&buftype' )
line 2: 
line 3:   if has_key( s:buftype_blacklist, buftype )
line 4:     return 0
line 5:   endif
line 6: 
line 7:   let filetype = getbufvar( a:buffer, '&filetype' )
line 8:   if empty( filetype )
line 9:     let filetype = 'ycm_nofiletype'
line 10:   endif
line 11: 
line 12:   let allowed = youcompleteme#filetypes#AllowedForFiletype( filetype )
calling youcompleteme#filetypes#AllowedForFiletype('ycm_nofiletype')

line 1:   let whitelist_allows = type( g:ycm_filetype_whitelist ) != v:t_dict || has_key( g:ycm_filetype_whitelist, '*' ) || s:HasAnyKey( g:ycm_filetype_whitelist, split( a:filetype, '\.' ) )
line 4:   let blacklist_allows = type( g:ycm_filetype_blacklist ) != v:t_dict || !s:HasAnyKey( g:ycm_filetype_blacklist, split( a:filetype, '\.' ) )
calling <SNR>43_HasAnyKey({'notes': 1, 'markdown': 1, 'netrw': 1... 1, 'text': 1, 'infolog': 1, 'mail': 1}, ['ycm_nofiletype'])

line 1:   for key in a:keys
line 2:     if has_key( a:dict, key )
line 3:       return 1
<SNR>43_HasAnyKey returning #1

continuing in youcompleteme#filetypes#AllowedForFiletype

line 6: 
line 7:   return whitelist_allows && blacklist_allows
youcompleteme#filetypes#AllowedForFiletype returning #0

continuing in <SNR>40_AllowedToCompleteInBuffer

line 13: 
line 14:   if !allowed || s:DisableOnLargeFile( a:buffer )
line 15:     return 0
<SNR>40_AllowedToCompleteInBuffer returning #0

continuing in <SNR>40_AllowedToCompleteInCurrentBuffer

<SNR>40_AllowedToCompleteInCurrentBuffer returning #0

continuing in <SNR>40_ReceiveMessages

line 3:     let poll_again = py3eval( 'ycm_state.OnPeriodicTick()' )
line 4:   endif
line 5: 
line 6:   if poll_again
line 7:     let s:pollers.receive_messages.id = timer_start( s:pollers.receive_messages.wait_milliseconds, function( 's:ReceiveMessages' ) )
line 10:   else
line 11:     " Don't poll again until we open another buffer
line 12:     let s:pollers.receive_messages.id = -1
line 13:   endif
<SNR>40_ReceiveMessages returning #0


Executing: q
Executing BufUnload Autocommands for "*"
autocommand call s:OnBufferUnload()

Executing: call s:OnBufferUnload()
calling <SNR>40_OnBufferUnload()

line 1:   " Expanding <abuf> returns the unloaded buffer number as a string but we want
line 2:   " it as a true number for the getbufvar function.
line 3:   let buffer_number = str2nr( expand( '<abuf>' ) )
line 4:   if !s:AllowedToCompleteInBuffer( buffer_number )
calling <SNR>40_AllowedToCompleteInBuffer(1)

line 1:   let buftype = getbufvar( a:buffer, '&buftype' )
line 2: 
line 3:   if has_key( s:buftype_blacklist, buftype )
line 4:     return 0
line 5:   endif
line 6: 
line 7:   let filetype = getbufvar( a:buffer, '&filetype' )
line 8:   if empty( filetype )
line 9:     let filetype = 'ycm_nofiletype'
line 10:   endif
line 11: 
line 12:   let allowed = youcompleteme#filetypes#AllowedForFiletype( filetype )
calling youcompleteme#filetypes#AllowedForFiletype('ycm_nofiletype')

line 1:   let whitelist_allows = type( g:ycm_filetype_whitelist ) != v:t_dict || has_key( g:ycm_filetype_whitelist, '*' ) || s:HasAnyKey( g:ycm_filetype_whitelist, split( a:filetype, '\.' ) )
line 4:   let blacklist_allows = type( g:ycm_filetype_blacklist ) != v:t_dict || !s:HasAnyKey( g:ycm_filetype_blacklist, split( a:filetype, '\.' ) )
calling <SNR>43_HasAnyKey({'notes': 1, 'markdown': 1, 'netrw': 1... 1, 'text': 1, 'infolog': 1, 'mail': 1}, ['ycm_nofiletype'])

line 1:   for key in a:keys
line 2:     if has_key( a:dict, key )
line 3:       return 1
<SNR>43_HasAnyKey returning #1

continuing in youcompleteme#filetypes#AllowedForFiletype

line 6: 
line 7:   return whitelist_allows && blacklist_allows
youcompleteme#filetypes#AllowedForFiletype returning #0

continuing in <SNR>40_AllowedToCompleteInBuffer

line 13: 
line 14:   if !allowed || s:DisableOnLargeFile( a:buffer )
line 15:     return 0
<SNR>40_AllowedToCompleteInBuffer returning #0

continuing in <SNR>40_OnBufferUnload

line 5:     return
<SNR>40_OnBufferUnload returning #0

continuing in BufUnload Autocommands for "*"

Writing ShaDa file "/home/burp/.local/state/nvim/shada/main.shada"
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases/Applications)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
chdir(/home/burp/Applications/.bash_aliases)
Executing VimLeave Autocommands for "*"
autocommand call s:OnVimLeave()

Executing: call s:OnVimLeave()
calling <SNR>40_OnVimLeave()

line 1:   " Workaround a NeoVim issue - not shutting down timers correctly
line 2:   " https://github.com/neovim/neovim/issues/6840
line 3:   for poller in values( s:pollers )
line 4:     call s:StopPoller( poller )
calling <SNR>40_StopPoller({'id': -1, 'wait_milliseconds': 100})

line 1:   call timer_stop( a:poller.id )
line 2:   let a:poller.id = -1
<SNR>40_StopPoller returning #0

continuing in <SNR>40_OnVimLeave

line 5:   endfor
line 3:   for poller in values( s:pollers )
line 4:     call s:StopPoller( poller )
calling <SNR>40_StopPoller({'id': -1, 'wait_milliseconds': 10})

line 1:   call timer_stop( a:poller.id )
line 2:   let a:poller.id = -1
<SNR>40_StopPoller returning #0

continuing in <SNR>40_OnVimLeave

line 5:   endfor
line 3:   for poller in values( s:pollers )
line 4:     call s:StopPoller( poller )
calling <SNR>40_StopPoller({'id': -1, 'wait_milliseconds': 10})

line 1:   call timer_stop( a:poller.id )
line 2:   let a:poller.id = -1
<SNR>40_StopPoller returning #0

continuing in <SNR>40_OnVimLeave

line 5:   endfor
line 3:   for poller in values( s:pollers )
line 4:     call s:StopPoller( poller )
calling <SNR>40_StopPoller({'id': 2, 'wait_milliseconds': 100})

line 1:   call timer_stop( a:poller.id )
line 2:   let a:poller.id = -1
<SNR>40_StopPoller returning #0

continuing in <SNR>40_OnVimLeave

line 5:   endfor
line 3:   for poller in values( s:pollers )
line 4:     call s:StopPoller( poller )
calling <SNR>40_StopPoller({'id': -1, 'wait_milliseconds': 100})

line 1:   call timer_stop( a:poller.id )
line 2:   let a:poller.id = -1
<SNR>40_StopPoller returning #0

continuing in <SNR>40_OnVimLeave

line 5:   endfor
line 3:   for poller in values( s:pollers )
line 4:     call s:StopPoller( poller )
calling <SNR>40_StopPoller({'id': -1, 'wait_milliseconds': 100})

line 1:   call timer_stop( a:poller.id )
line 2:   let a:poller.id = -1
<SNR>40_StopPoller returning #0

continuing in <SNR>40_OnVimLeave

line 5:   endfor
line 3:   for poller in values( s:pollers )
line 4:     call s:StopPoller( poller )
calling <SNR>40_StopPoller({'id': -1, 'wait_milliseconds': 100})

line 1:   call timer_stop( a:poller.id )
line 2:   let a:poller.id = -1
<SNR>40_StopPoller returning #0

continuing in <SNR>40_OnVimLeave

line 5:   endfor
line 3:   for poller in values( s:pollers )
line 4:     call s:StopPoller( poller )
calling <SNR>40_StopPoller({'id': -1, 'requests': {}, 'wait_milliseconds': 100})

line 1:   call timer_stop( a:poller.id )
line 2:   let a:poller.id = -1
<SNR>40_StopPoller returning #0

continuing in <SNR>40_OnVimLeave

line 5:   endfor
line 3:   for poller in values( s:pollers )
line 4:     call s:StopPoller( poller )
line 5:   endfor
line 6:   py3 ycm_state.OnVimLeave()
calling provider#python3#Call('execute', ['ycm_state.OnVimLeave()', 1, 1])

line 1:   if s:err != ''
line 2:     return
line 3:   endif
line 4:   if !exists('s:host')
line 5:     let s:rpcrequest = function('rpcrequest')
line 6: 
line 7:     " Ensure that we can load the Python3 host before bootstrapping
line 8:     try
line 9:       let s:host = remote#host#Require('legacy-python3-provider')
line 10:     catch
line 11:       let s:err = v:exception
line 12:       echohl WarningMsg
line 13:       echomsg v:exception
line 14:       echohl None
line 15:       return
line 16:     endtry
line 17:   endif
line 18:   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))
provider#python3#Call returning v:null

continuing in <SNR>40_OnVimLeave

<SNR>40_OnVimLeave returning #0

continuing in VimLeave Autocommands for "*"
